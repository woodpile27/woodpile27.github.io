<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Go 应用内存泄漏问题的解决 · woodpile27</title><meta name="description" content="Go 应用内存泄漏问题的解决 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://woodpile27.cn/atom.xml" title="woodpile27"><meta name="generator" content="Hexo 5.0.2"><link rel="alternate" href="/atom.xml" title="woodpile27" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/woodpile27" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Go 应用内存泄漏问题的解决</h1><div class="post-info">Sep 15, 2020</div><div class="post-content"><p>部署的一个 Go 语言写的程序出现内存占用逐渐上升的情况，排查了一段时间终于找到了原因。</p>
<h3 id="pprof"><a href="#pprof" class="headerlink" title="pprof"></a>pprof</h3><p>当出现内存占用不断上升的情况时，首先考虑是不是出现了内存泄露的问题。于是用 pprof 对程序进行持续的监控，从结果来看，goroutine 的数量一直在一个稳定的范围内，排除 goroutine 泄漏的情况。<br>接着讲目光转移到 inuse_space，然后看到了让我当时很疑惑的结果：<br><strong>pprof 的结果与实际的内存占用结果出现了很大的差异</strong> ，pprof 看到的内存占用只有个位数的 MB，而无论是 docker 占用的内存亦或是在容器里 top 看到的内存占用都达到了上百兆。</p>
<p>在一番 google 之下找到了原因：<br>pprof 看到的内存占用，其实只是 golang 逻辑上正在使用的内存量，不包括已被 GC 回收但尚未返还给操作系统的内存，同样也不包含内核态的内存占用，而 top 是站在操作系统层面看到的进程内存占用，理论上就是会比 pprof 看到的内存占用量更多。如果在工作中发现 top 看到占用的内存很大，而 pprof 看到的内存占用不多，有可能是两个问题导致的：</p>
<ul>
<li>有大量内存被 GC 但还没有来得及返还给操作系统</li>
<li>某些内核态操作（比如 I/O ）消耗了大量内存</li>
</ul>
<h3 id="byte-导致的问题？"><a href="#byte-导致的问题？" class="headerlink" title="[]byte 导致的问题？"></a>[]byte 导致的问题？</h3><p>我的程序在运行中会频繁的创建大量的 []byte，并且 []byte 的长度也不小。而用 pprof 发现这部分代码占用的内存确实较多，猜测是不是这部分占用的内存被 GC 后没有及时反还给操作系统。<br>stackoverflow 上有这样一个<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/37382600/cannot-free-memory-once-occupied-by-bytes-buffer">问题</a>：无法释放由 bytes.Buffer 占用的内存。高赞回答：</p>
<blockquote>
<p>Go 是一种垃圾回收语言，这意味着当这些变量变得不可访问时，垃圾回收器会自动释放变量分配和使用的内存。释放的内存并不意味着将其返回给操作系统，释放的内存意味着可以回收该内存，并在需要时将其重新用于另一个变量。因此在操作系统中，不会仅由于某些变量变得不可访问而垃圾回收器检测到此变量并释放它所使用的内存就立刻看到内存减少。</p>
<p>但是如果 Go 运行一段时间（通常为5分钟）不使用，它将把内存返回给 OS。如果在此期间内存使用量增加，则很有可能不会将内存返回给操作系统。如果等待一段时间而不重新分配内存，则释放的内存最终将返回给操作系统（不是所有内存，而是未使用的“大块”内存）。如果想迫不及待发生这种情况，可以调用 debug.FreeOSMemory() 强制执行。</p>
</blockquote>
<p>这篇<a target="_blank" rel="noopener" href="https://blog.cloudflare.com/recycling-memory-buffers-in-go/">文章</a>同样指出了类似的问题，但是通过运行作者的示例程序发现 HeapReleased 也即回收到操作系统的内存，并非像作者描述的不会经常变化，相反其变化的非常快，也就是 Go 在不断在操作系统中回收内存。<br>原因应该是这两篇文章都已经年代久远，Go 的更新迭代已经解决了上述问题。</p>
<h3 id="go-python"><a href="#go-python" class="headerlink" title="go-python"></a>go-python</h3><p>之后我又将目光转向 go-python，程序中会不断通过 go-python 调用一个 python 脚本，而 go-python 是通过 cgo 调用 libpython 实现的。<br>问题是否出在这儿呢？首先我进行了验证，即注释掉了相关代码并且使 CGO_ENABLED=0，测试结果发现程序没有出现之前的内存泄漏情况，于是终于找到了问题所在。<br>在 go-python 项目中有一个 <strong>memory leak</strong> 的 issue 吸引了我的注意：</p>
<blockquote>
<p>When to call GC？Do users need manual GC?</p>
</blockquote>
<blockquote>
<p>go-python is calling the CPython API through Cgo.<br>so you have to program as in C and follow the reference counting of the CPython API (calling python.Object.IncRef() and python.Object.DecRef().)</p>
<p>there’s no GC involved.<br><strong>you need to manually manage memory.</strong></p>
</blockquote>
<p>问题在于使用者需要手动管理内存，PyObject 对象使用结束后需要主动调用 <strong>DecRef</strong> ，通过减少引用计数的方式释放，否则就会发生内存泄漏的情况。实测 <strong>DecRef</strong> 可能会引发某些问题，可以根据 go-python 文档的推荐改用 <strong>Clear</strong> 。</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016412013">https://segmentfault.com/a/1190000016412013</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000019929993">https://segmentfault.com/a/1190000019929993</a><br><a target="_blank" rel="noopener" href="https://github.com/wolfogre/go-pprof-practice/issues/1">https://github.com/wolfogre/go-pprof-practice/issues/1</a><br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/37382600/cannot-free-memory-once-occupied-by-bytes-buffer/37383604#37383604">https://stackoverflow.com/questions/37382600/cannot-free-memory-once-occupied-by-bytes-buffer/37383604#37383604</a><br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/45509538/freeing-unused-memory">https://stackoverflow.com/questions/45509538/freeing-unused-memory</a><br><a target="_blank" rel="noopener" href="https://blog.cloudflare.com/recycling-memory-buffers-in-go/">https://blog.cloudflare.com/recycling-memory-buffers-in-go/</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2020/09/16/docker-monitor/" class="prev">PREV</a><a href="/2020/08/19/http-honeypot/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2021 <a href="http://woodpile27.cn">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>